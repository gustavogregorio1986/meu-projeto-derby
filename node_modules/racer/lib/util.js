Object.defineProperty(exports, "__esModule", { value: true });
exports.use = exports.serverUse = exports.serverRequire = exports.promisify = exports.mergeInto = exports.mayImpact = exports.mayImpactAny = exports.lookup = exports.isArrayIndex = exports.equalsNaN = exports.equal = exports.deepCopy = exports.copyObject = exports.copy = exports.contains = exports.castSegments = exports.asyncGroup = exports.isServer = exports.deepEqual = void 0;
/** @private */
exports.deepEqual = require('fast-deep-equal');
/**
 * Checks process.title is not equal to 'browser'
 *
 * Set as 'browser' via build tools (e.g. webpack) to package
 * browser specific code to bundle
 *
 * see {@link https://github.com/derbyjs/derby-webpack/blob/main/createConfig.js#L95 | derby-webpack}
 */
exports.isServer = process.title !== 'browser';
/** @private */
function asyncGroup(cb) {
    var group = new AsyncGroup(cb);
    return function asyncGroupAdd() {
        return group.add();
    };
}
exports.asyncGroup = asyncGroup;
var AsyncGroup = /** @class */ (function () {
    function AsyncGroup(cb) {
        this.cb = cb;
        this.isDone = false;
        this.count = 0;
    }
    AsyncGroup.prototype.add = function () {
        this.count++;
        var self = this;
        return function (err) {
            self.count--;
            if (self.isDone)
                return;
            if (err) {
                self.isDone = true;
                self.cb(err);
                return;
            }
            if (self.count > 0)
                return;
            self.isDone = true;
            self.cb();
        };
    };
    return AsyncGroup;
}());
/** @private */
function castSegment(segment) {
    return (typeof segment === 'string' && isArrayIndex(segment))
        ? +segment // sneaky op to convert numeric string to number
        : segment;
}
/** @private */
function castSegments(segments) {
    // Cast number path segments from strings to numbers
    return segments.map(function (segment) { return castSegment(segment); });
}
exports.castSegments = castSegments;
/** @private */
function contains(segments, testSegments) {
    for (var i = 0; i < segments.length; i++) {
        if (segments[i] !== testSegments[i])
            return false;
    }
    return true;
}
exports.contains = contains;
/** @private */
function copy(value) {
    if (value instanceof Date)
        return new Date(value);
    if (typeof value === 'object') {
        if (value === null)
            return null;
        if (Array.isArray(value))
            return value.slice();
        return copyObject(value);
    }
    return value;
}
exports.copy = copy;
/** @private */
function copyObject(object) {
    var out = new object.constructor();
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            out[key] = object[key];
        }
    }
    return out;
}
exports.copyObject = copyObject;
/** @private */
function deepCopy(value) {
    if (value instanceof Date)
        return new Date(value);
    if (typeof value === 'object') {
        if (value === null)
            return null;
        if (Array.isArray(value)) {
            var array = [];
            for (var i = value.length; i--;) {
                array[i] = deepCopy(value[i]);
            }
            return array;
        }
        var object = new value.constructor();
        for (var key in value) {
            if (value.hasOwnProperty(key)) {
                object[key] = deepCopy(value[key]);
            }
        }
        return object;
    }
    return value;
}
exports.deepCopy = deepCopy;
/** @private */
function equal(a, b) {
    return (a === b) || (equalsNaN(a) && equalsNaN(b));
}
exports.equal = equal;
/** @private */
function equalsNaN(x) {
    // eslint-disable-next-line no-self-compare
    return x !== x;
}
exports.equalsNaN = equalsNaN;
/** @private */
function isArrayIndex(segment) {
    return (/^[0-9]+$/).test(segment);
}
exports.isArrayIndex = isArrayIndex;
/** @private */
function lookup(segments, value) {
    if (!segments)
        return value;
    for (var i = 0, len = segments.length; i < len; i++) {
        if (value == null)
            return value;
        value = value[segments[i]];
    }
    return value;
}
exports.lookup = lookup;
/** @private */
function mayImpactAny(segmentsList, testSegments) {
    for (var i = 0, len = segmentsList.length; i < len; i++) {
        if (mayImpact(segmentsList[i], testSegments))
            return true;
    }
    return false;
}
exports.mayImpactAny = mayImpactAny;
/** @private */
function mayImpact(segments, testSegments) {
    var len = Math.min(segments.length, testSegments.length);
    for (var i = 0; i < len; i++) {
        if (segments[i] !== testSegments[i])
            return false;
    }
    return true;
}
exports.mayImpact = mayImpact;
/** @private */
function mergeInto(to, from) {
    for (var key in from) {
        to[key] = from[key];
    }
    return to;
}
exports.mergeInto = mergeInto;
/** @private */
function promisify(original) {
    if (typeof original !== 'function') {
        throw new TypeError('The "original" argument must be of type Function');
    }
    function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function (resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
        });
        var args = Array.prototype.slice.apply(arguments);
        args.push(function (err, value) {
            if (err) {
                promiseReject(err);
            }
            else {
                promiseResolve(value);
            }
        });
        try {
            original.apply(this, args);
        }
        catch (err) {
            promiseReject(err);
        }
        return promise;
    }
    return fn;
}
exports.promisify = promisify;
/**
 * Conditionally require module only if in server process. No-op when called in browser.
 *
 * @param module
 * @param id
 * @returns module or undefined
 */
function serverRequire(module, id) {
    if (!exports.isServer)
        return;
    return module.require(id);
}
exports.serverRequire = serverRequire;
/**
 * Use plugin only if invoked in server process.
 *
 * @param module
 * @param id
 * @param options - Optional
 * @returns
 */
function serverUse(module, id, options) {
    if (!exports.isServer)
        return this;
    var plugin = module.require(id);
    return this.use(plugin, options);
}
exports.serverUse = serverUse;
/**
 * Use plugin
 *
 * @param plugin
 * @param options - Optional options passed to plugin
 * @returns
 */
function use(plugin, options) {
    // Don't include a plugin more than once
    var plugins = this._plugins || (this._plugins = []);
    if (plugins.indexOf(plugin) === -1) {
        plugins.push(plugin);
        plugin(this, options);
    }
    return this;
}
exports.use = use;
