import { Model } from './Model';
import type { Path, PathLike, Segments } from '../types';
interface PaginationOptions {
    skip?: number;
    limit?: number;
}
type FilterFn<S> = ((item: S, key: string, object: {
    [key: string]: S;
}) => boolean) | string | null;
type SortFn<S> = (a: S, B: S) => number;
declare module './Model' {
    interface Model {
        /**
         * Creates a live-updating list from items in an object, which results in
         * automatically updating as the input items change.
         *
         * @param inputPath - Path pointing to an object or array. The path's value is
         *   retrieved via model.get(), and each item checked against filter function
         * @param additionalInputPaths - Other parameters can be set in the model, and
         *   the filter function will be re-evaluated when these parameters change as well.
         * @param options
         *   skip - The number of first results to skip
         *   limit - The maximum number of results. A limit of zero is equivalent to no limit.
         * @param fn - A function or the name of a function defined via model.fn(). The function
         *   should have the arguments function(item, key, object, additionalInputs...)
         *
         * @see https://derbyjs.github.io/derby/models/filters-sorts
         */
        filter<S>(inputPath: PathLike, additionalInputPaths: PathLike[], options: PaginationOptions, fn: FilterFn<S>): Filter<S>;
        filter<S>(inputPath: PathLike, additionalInputPaths: PathLike[], fn: FilterFn<S>): Filter<S>;
        filter<S>(inputPath: PathLike, options: PaginationOptions, fn: FilterFn<S>): Filter<S>;
        filter<S>(inputPath: PathLike, fn: FilterFn<S>): Filter<S>;
        removeAllFilters: (subpath: Path) => void;
        /**
         * Creates a live-updating list from items in an object, which results in
         * automatically updating as the input items change. The results are sorted by ascending order (default) or by a provided 'fn' parameter.
         *
         * @param inputPath - Path pointing to an object or array. The path's value is
         *   retrieved via model.get(), and each item checked against filter function
         * @param additionalInputPaths - Other parameters can be set in the model, and
         *   the filter function will be re-evaluated when these parameters change as well.
         * @param options
         *   skip - The number of first results to skip
         *   limit - The maximum number of results. A limit of zero is equivalent to no limit.
         * @param fn - A function or the name of a function defined via model.fn().
         *
         * @see https://derbyjs.github.io/derby/models/filters-sorts
         */
        sort<S>(inputPath: PathLike, additionalInputPaths: PathLike[], options: PaginationOptions, fn: SortFn<S>): Filter<S>;
        sort<S>(inputPath: PathLike, additionalInputPaths: PathLike[], fn: SortFn<S>): Filter<S>;
        sort<S>(inputPath: PathLike, options: PaginationOptions, fn: SortFn<S>): Filter<S>;
        sort<S>(inputPath: PathLike, fn: SortFn<S>): Filter<S>;
        _filters: Filters;
        _removeAllFilters: (segments: Segments) => void;
    }
}
declare class FromMap {
}
declare class Filters {
    model: Model;
    fromMap: FromMap;
    constructor(model: any);
    add(path: Path, filterFn: any, sortFn: any, inputPaths: any, options: any): Filter<unknown>;
    toJSON(): any[];
}
export declare class Filter<T> {
    bundle: boolean;
    filterFn: any;
    filterName: string;
    filters: any;
    from: string;
    fromSegments: string[];
    idsSegments: Segments;
    inputPaths: any;
    inputsSegments: Segments[];
    limit: number;
    model: Model<T>;
    options: any;
    path: string;
    segments: Segments;
    skip: number;
    sortFn: any;
    sortName: string;
    constructor(filters: any, path: any, filterFn: any, sortFn: any, inputPaths: any, options: any);
    filter(fn: any): this;
    sort(fn: any): this;
    _slice(results: any): any;
    getInputs(): any[];
    callFilter(items: any, key: any, inputs: any): any;
    ids(): string[];
    get<S = unknown>(): S[];
    update(pass?: any): void;
    ref(from: any): import("./refList").RefList;
    destroy(): void;
}
export {};
