import type { Callback, Path, ArrayItemType, Segments } from '../types';
type ValueCallback<T> = ((error: Error | undefined, value: T) => void);
declare module './Model' {
    interface Model<T> {
        _mutate(segments: any, fn: any, cb: any): void;
        set(value: T, cb?: ErrorCallback): T | undefined;
        set<S>(subpath: Path, value: any, cb?: ErrorCallback): S | undefined;
        setPromised(value: T): Promise<void>;
        setPromised(subpath: Path, value: any): Promise<void>;
        _set<S>(segments: Segments, value: any, cb?: ErrorCallback): S | undefined;
        setNull(value: T, cb?: ErrorCallback): T | undefined;
        setNull<S>(subpath: Path, value: S, cb?: ErrorCallback): S | undefined;
        setNullPromised(value: T): Promise<void>;
        setNullPromised(subpath: Path, value: any): Promise<void>;
        _setNull<S>(segments: Segments, value: S, cb?: ErrorCallback): S | undefined;
        setEach(value: any, cb?: ErrorCallback): void;
        setEach(subpath: Path, value: any, cb?: ErrorCallback): void;
        setEachPromised(value: any): Promise<void>;
        setEachPromised(subpath: Path, value: any): Promise<void>;
        _setEach(segments: Segments, value: any, cb?: ErrorCallback): void;
        create(value: any, cb?: ErrorCallback): void;
        create(subpath: Path, value: any, cb?: ErrorCallback): void;
        createPromised(value: any): Promise<void>;
        createPromised(subpath: Path, value: any): Promise<void>;
        _create(segments: Segments, value: any, cb?: ErrorCallback): void;
        createNull(value: any, cb?: ErrorCallback): void;
        createNull(subpath: Path, value: any, cb?: ErrorCallback): void;
        createNullPromised(value: any): Promise<void>;
        createNullPromised(subpath: Path, value: any): Promise<void>;
        _createNull(segments: Segments, value: any, cb?: ErrorCallback): void;
        /**
         * Adds a document to the collection, under an id subpath corresponding
         * to either the document's `id` property if present, or else a new randomly
         * generated id.
         *
         * If a callback is provided, it's called when the write is committed or
         * fails.
         *
         * @param value - Document to add
         * @param cb - Optional callback
         */
        add(value: any, cb?: ValueCallback<string>): string;
        /**
         * Adds a document to the collection, under an id subpath corresponding
         * to either the document's `id` property if present, or else a new randomly
         * generated id.
         *
         * If a callback is provided, it's called when the write is committed or
         * fails.
         *
         * @param subpath - Optional Collection under which to add the document
         * @param value - Document to add
         * @param cb - Optional callback
         */
        add(subpath: Path, value: any, cb?: ValueCallback<string>): string;
        addPromised(value: any): Promise<string>;
        addPromised(subpath: Path, value: any): Promise<string>;
        _add(segments: Segments, value: any, cb?: ValueCallback<string>): string;
        /**
         * Deletes the value at this relative subpath.
         *
         * If a callback is provided, it's called when the write is committed or
         * fails.
         *
         * @typeParam S - Type of the data returned by delete operation
         * @param subpath
         * @returns the old value at the path
         */
        del<S>(subpath: Path, cb?: Callback): S | undefined;
        /**
         * Deletes the value at this model's path.
         *
         * If a callback is provided, it's called when the write is committed or
         * fails.
         *
         * @typeParam T - Type of the data returned by delete operation
         * @returns the old value at the path
         */
        del<T>(cb?: Callback): T | undefined;
        /**
         * Deletes the value at this relative subpath. If not provided deletes at model path
         *
         * Promise resolves when commit succeeds, rejected on commit failure.
         *
         * @param subpath - Optional subpath to delete
         * @returns promise
         */
        delPromised(subpath?: Path): Promise<void>;
        _del<S>(segments: Segments, cb?: ErrorCallback): S;
        _delNoDereference(segments: Segments, cb?: ErrorCallback): void;
        increment(value?: number): number;
        increment(subpath: Path, value?: number, cb?: ErrorCallback): number;
        incrementPromised(value?: number): Promise<void>;
        incrementPromised(subpath: Path, value?: number): Promise<void>;
        _increment(segments: Segments, value: number, cb?: ErrorCallback): number;
        /**
         * Push a value to a model array
         *
         * @param value
         * @returns the length of the array
         */
        push(value: any): number;
        /**
         * Push a value to a model array at subpath
         *
         * @param subpath
         * @param value
         * @returns the length of the array
         */
        push(subpath: Path, value: any, cb?: ErrorCallback): number;
        pushPromised(value: any): Promise<void>;
        pushPromised(subpath: Path, value: any): Promise<void>;
        _push(segments: Segments, value: any, cb?: ErrorCallback): number;
        unshift(value: any): void;
        unshift(subpath: Path, value: any, cb?: ErrorCallback): void;
        unshiftPromised(value: any): Promise<void>;
        unshiftPromised(subpath: Path, value: any): Promise<void>;
        _unshift(segments: Segments, value: any, cb?: ErrorCallback): void;
        insert(index: number, value: any): void;
        insert(subpath: Path, index: number, value: any, cb?: ErrorCallback): void;
        insertPromised(value: any, index: number): Promise<void>;
        insertPromised(subpath: Path, index: number, value: any): Promise<void>;
        _insert(segments: Segments, index: number, value: any, cb?: ErrorCallback): void;
        /**
         * Removes an item from the end of the array at this model's path or a
         * relative subpath.
         *
         * If a callback is provided, it's called when the write is committed or
         * fails.
         * @typeParam V - type of data at subpath
         * @param subpath
         * @returns the removed item
         */
        pop<V>(subpath: Path, cb?: Callback): V | undefined;
        pop<V extends ArrayItemType<T>>(cb?: Callback): V | undefined;
        popPromised(value: any): Promise<void>;
        popPromised(subpath: Path, value: any): Promise<void>;
        _pop(segments: Segments, value: any, cb?: ErrorCallback): void;
        shift<S>(subpath?: Path, cb?: ErrorCallback): S;
        shiftPromised(subpath?: Path): Promise<void>;
        _shift<S>(segments: Segments, cb?: ErrorCallback): S;
        /**
         * Removes one or more items from the array at this model's path or a
         * relative subpath.
         *
         * If a callback is provided, it's called when the write is committed or
         * fails.
         *
         * @typeParam - Type of data targeted by remove operation
         * @param subpath - Subpath to remove
         * @param index - 0-based index at which to start removing items
         * @param howMany - Number of items to remove. Defaults to `1`.
         * @returns array of the removed items
         */
        remove<V>(subpath: Path, index: number, howMany?: number, cb?: Callback): V[];
        remove<V extends ArrayItemType<T>>(index: number, howMany?: number, cb?: Callback): V[];
        removePromised(index: number): Promise<void>;
        removePromised(subpath: Path): Promise<void>;
        removePromised(index: number, howMany: number): Promise<void>;
        removePromised(subpath: Path, index: number): Promise<void>;
        removePromised(subpath: Path, index: number, howMany: number): void;
        _remove(segments: Segments, index: number, howMany: number, cb?: ErrorCallback): void;
        move(from: number, to: number, cb?: ErrorCallback): void;
        move(from: number, to: number, howMany: number, cb?: ErrorCallback): void;
        move(subpath: Path, from: number, to: number, cb?: ErrorCallback): void;
        move(subpath: Path, from: number, to: number, howmany: number, cb?: ErrorCallback): void;
        movePromised(from: number, to: number): Promise<void>;
        movePromised(from: number, to: number, howMany: number): Promise<void>;
        movePromised(subpath: Path, from: number, to: number): Promise<void>;
        movePromised(subpath: Path, from: number, to: number, howmany: number): Promise<void>;
        _move(segments: Segments, from: number, to: number, owMany: number, cb?: ErrorCallback): void;
        stringInsert(index: number, text: string, cb?: ErrorCallback): void;
        stringInsert(subpath: Path, index: number, text: string, cb?: ErrorCallback): void;
        stringInsertPromised(index: number, text: string): Promise<void>;
        stringInsertPromised(subpath: Path, index: number, text: string): Promise<void>;
        _stringInsert(segments: Segments, index: number, text: string, cb?: ErrorCallback): void;
        stringRemove(index: number, howMany: number, cb?: ErrorCallback): void;
        stringRemove(subpath: Path, index: number, cb?: ErrorCallback): void;
        stringRemove(subpath: Path, index: number, howMany: number, cb?: ErrorCallback): void;
        stringRemovePromised(index: number, howMany: number): Promise<void>;
        stringRemovePromised(subpath: Path, index: number): Promise<void>;
        stringRemovePromised(subpath: Path, index: number, howMany: number): Promise<void>;
        _stringRemove(segments: Segments, index: number, howMany: number, cb?: ErrorCallback): void;
        subtypeSubmit(subtype: any, subtypeOp: any, cb?: ErrorCallback): void;
        subtypeSubmit(subpath: Path, subtype: any, subtypeOp: any, cb?: ErrorCallback): void;
        subtypeSubmitPromised(subtype: any, subtypeOp: any): Promise<void>;
        subtypeSubmitPromised(subpath: Path, subtype: any, subtypeOp: any): Promise<void>;
        _subtypeSubmit(segments: Segments, subtype: any, subtypeOp: any, cb?: ErrorCallback): void;
    }
}
export {};
