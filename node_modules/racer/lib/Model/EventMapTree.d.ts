import { type Segments } from '../types';
/**
 * Construct a tree root when invoked without any arguments. Children nodes are
 * constructred internally as needed on calls to addListener()
 *
 * @param {EventMapTree} [parent]
 * @param {string} [segment]
 */
export declare class EventMapTree {
    parent?: EventMapTree;
    segment?: string;
    children: any;
    listener: any;
    constructor(parent?: EventMapTree, segment?: string);
    /**
     * Remove the reference to this node from its parent so that it can be garbage
     * collected. This is called internally when all listener to a node
     * are removed
     */
    destroy(): void;
    /**
     * Get a node for a path if it exists
     *
     * @param  {string[]} segments
     * @return {EventMapTree|undefined}
     */
    _getChild(segments: Segments): this;
    /**
     * If a path already has a node, return it. Otherwise, create the node and
     * parents in a lazy manner and return the node for the path
     *
     * @param  {string[]} segments
     * @return {EventMapTree}
     */
    _getOrCreateChild(segments: Segments): EventMapTree;
    /**
     * Assign a listener to a path location. Listener may be any type of value.
     * Return the previous listener value if any
     *
     * @param  {string[]} segments
     * @param  {*} listener
     * @return {*} previous
     */
    setListener(segments: Segments, listener: any): any;
    /**
     * Remove the listener at a path location and return it
     *
     * @param  {string[]} segments
     * @return {*} previous
     */
    deleteListener(segments: Segments): any;
    /**
     * Remove all listeners and descendent listeners for a path location. Return the
     * node for the path location if any
     *
     * @param  {string[]} segments
     * @return {EventMapTree}
     */
    deleteAllListeners(segments: Segments): this;
    /**
     * Return the direct listener to `segments` if any
     *
     * @param  {string[]} segments
     * @return {*} listeners
     */
    getListener(segments: Segments): any;
    /**
     * Return an array with each of the listeners that may be affected by a change
     * to `segments`. These are:
     *   1. Listeners to each node from the root to the node for `segments`
     *   2. Listeners to all descendent nodes under `segments`
     *
     * @param  {string[]} segments
     * @return {Array} listeners
     */
    getAffectedListeners(segments: any): any[];
    /**
     * Call the callback with each listener to the node and its decendants
     *
     * @param {EventMapTree} node
     * @param {Function} callback
     */
    forEach(callback: any): void;
}
