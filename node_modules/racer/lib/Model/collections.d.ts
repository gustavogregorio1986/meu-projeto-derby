import { Doc } from './Doc';
import { RootModel } from './Model';
import { JSONObject } from 'sharedb/lib/sharedb';
import type { Path, ReadonlyDeep, ShallowCopiedValue, Segments } from '../types';
export declare class ModelCollections {
    docs: Record<string, any>;
}
/** Root model data */
export declare class ModelData {
    [collectionName: string]: CollectionData<JSONObject>;
}
declare class DocMap {
    [id: string]: Doc;
}
/** Dictionary of document id to document data */
export declare class CollectionData<T extends {}> {
    [id: string]: T;
}
declare module './Model' {
    interface RootModel {
        collections: ModelCollections;
        data: ModelData;
    }
    interface Model<T> {
        destroy(subpath?: Path): void;
        /**
         * Gets the value located at this model's path.
         *
         * If no value exists at the path, this returns `undefined`.
         *
         * _Note:_ The value is returned by reference, and object values should not
         * be directly modified - use the Model mutator methods instead. The
         * TypeScript compiler will enforce no direct modifications, but there are
         * no runtime guards, which means JavaScript source code could still
         * improperly make direct modifications.
         */
        get(): ReadonlyDeep<T> | undefined;
        /**
         * Gets the value located at a relative subpath.
         *
         * If no value exists at the path, this returns `undefined`.
         *
         * _Note:_ The value is returned by reference, and object values should not
         * be directly modified - use the Model mutator methods instead. The
         * TypeScript compiler will enforce no direct modifications, but there are
         * no runtime guards, which means JavaScript source code could still
         * improperly make direct modifications.
         *
         * @param subpath
         */
        get<S>(subpath?: Path): ReadonlyDeep<S> | undefined;
        getCollection(collectionName: string): Collection<JSONObject>;
        /**
         * Gets a shallow copy of the value located at this model's path or a relative
         * subpath.
         *
         * If no value exists at the path, this returns `undefined`.
         *
         * @param subpath
         */
        getCopy<S>(subpath: Path): ShallowCopiedValue<S> | undefined;
        getCopy(): ShallowCopiedValue<T> | undefined;
        /**
         * Gets a deep copy of the value located at this model's path or a relative
         * subpath.
         *
         * If no value exists at the path, this returns `undefined`.
         *
         * @param subpath
         */
        getDeepCopy<S>(subpath: Path): S | undefined;
        getDeepCopy(): T | undefined;
        getDoc(collecitonName: string, id: string): any | undefined;
        getOrCreateCollection(name: string): Collection;
        getOrCreateDoc(collectionName: string, id: string, data: any): any;
        /**
         * Gets value at the path if not nullish, otherwise returns provided default value
         *
         * @param subpath
         * @param defaultValue value to return if no value at subpath
         */
        getOrDefault<S>(subpath: Path, defaultValue: S): ReadonlyDeep<S>;
        /**
         * Gets the value located at this model's path or a relative subpath.
         *
         * If no value exists at the path, or the value is nullish (null or undefined), this will throw an error.
         * @param subpath
         */
        getOrThrow<S>(subpath: Path): ReadonlyDeep<S>;
        _get(segments: Segments): any;
        _getCopy(segments: Segments): any;
        _getDeepCopy(segments: Segments): any;
        /**
         * Gets array of values of collection at this model's path or relative subpath
         *
         * If no values exist at subpath, an empty array is returned
         * @param subpath
         */
        getValues<S>(subpath?: Path): ReadonlyDeep<S>[];
    }
}
export declare class Collection<T extends JSONObject = {}> {
    model: RootModel;
    name: string;
    size: number;
    docs: DocMap;
    data: CollectionData<T>;
    Doc: typeof Doc;
    constructor(model: RootModel, name: string, docClass: typeof Doc);
    /**
     * Adds a document with `id` and `data` to `this` Collection.
     * @param {String} id
     * @param {Object} data
     * @return {LocalDoc|RemoteDoc} doc
     */
    add(id: any, data: any): Doc;
    destroy(): void;
    getOrCreateDoc(id: any, data: any): Doc;
    /**
     * Removes the document with `id` from `this` Collection. If there are no more
     * documents in the Collection after the given document is removed, then this
     * destroys the Collection.
     *
     * @param {String} id
     */
    remove(id: string): void;
}
export {};
