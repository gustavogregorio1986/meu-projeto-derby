/// <reference types="node" />
import { EventEmitter } from 'events';
import { EventListenerTree } from './EventListenerTree';
import type { Path, PathLike, Segments } from '../types';
export type ModelEvent = ChangeEvent | InsertEvent | RemoveEvent | MoveEvent | LoadEvent | UnloadEvent;
export type ModelOnEventMap = {
    [eventName in ModelEvent['type']]: Extract<ModelEvent, {
        type: eventName;
    }>;
};
export type ModelOnImmediateEventMap = {
    [eventName in ModelEvent['_immediateType']]: Extract<ModelEvent, {
        _immediateType: eventName;
    }>;
};
/**
 * With `useEventObjects: true` captures are emmitted as
 * ['foo.bar.1']
 *  */
type EventObjectCaptures = string[];
declare module './Model' {
    interface RootModel {
        on<T extends keyof ModelOnEventMap>(eventType: T, pathPattern: PathLike, options: {
            useEventObjects: true;
        }, listener: (event: ModelOnEventMap[T], captures: EventObjectCaptures) => void): () => void;
        on(eventType: 'all', pathPattern: PathLike, options: {
            useEventObjects: true;
        }, listener: (event: ModelEvent, captures: EventObjectCaptures) => void): () => void;
        on<T extends keyof ModelOnEventMap>(eventType: T, options: {
            useEventObjects: true;
        }, listener: (event: ModelOnEventMap[T], captures: EventObjectCaptures) => void): () => void;
        on(eventType: 'all', options: {
            useEventObjects: true;
        }, listener: (event: ModelEvent, captures: EventObjectCaptures) => void): () => void;
        on<T extends keyof ModelOnImmediateEventMap>(eventType: T, listener: (pathSegments: string[], event: ModelOnImmediateEventMap[T]) => void): () => void;
        on(eventType: 'all', listener: (pathSegments: string[], event: ModelOnEventMap[keyof ModelOnEventMap]) => void): () => void;
        on(eventType: 'error', listener: (error: Error) => void): () => void;
    }
    interface Model<T> {
        addListener(event: string, listener: any, arg2?: any, arg3?: any): any;
        /**
         * Returns a child model based off the current model, with the specified "event context" tag
         * applied to all event listeners registered using that child model.
         *
         * `removeContextListeners()` can later be used to remove all listeners that were added with
         * that model's event context.
         *
         * Note that this has nothing to do with the `context(contextId)` method.
         *
         * @param id event context tag
         */
        eventContext(id: string): ChildModel<T>;
        /**
         * Listen to Racer events matching a certain path or path pattern.
         *
         * `pathPattern` is a path pattern that will filter emitted events, calling
         * the handler function only when a mutator matches the pattern.
         *
         * Path patterns support a single segment wildcard `'*'` anywhere in a path,
         * and a multi-segment wildcard `'**'` at the end of the path. The
         * multi-segment wildcard alone `'**'` matches all paths.
         *
         * Examples of path patterns:
         * * `'notes.abc-123.author'` - Trigger on a direct modification to a
         *   specific note's `author`. Will not trigger if a sub-property of the
         *   author is modified or if the entire note is replaced.
         * * `notes.*.author` - Trigger on a direct modification to any note's
         *   `author`. Will not trigger if a sub-property of the author is modified
         *    or if an entire note is replaced.
         * * `notes.*.author.**` - Trigger on a modification to any note's `author`
         *   or any sub-property of `author`. Will not trigger if an entire note is
         *   replaced.
         *
         * @param eventType
         * @param pathPattern
         * @param options
         * @param listener
         *
         * @see https://derbyjs.github.io/derby/models/events
         */
        on<T extends keyof ModelOnEventMap>(eventType: T, pathPattern: PathLike, options: {
            useEventObjects: true;
        }, listener: (event: ModelOnEventMap[T], captures: EventObjectCaptures) => void): () => void;
        on(eventType: 'all', pathPattern: PathLike, options: {
            useEventObjects: true;
        }, listener: (event: ModelEvent, captures: EventObjectCaptures) => void): () => void;
        on<T extends keyof ModelOnEventMap>(eventType: T, options: {
            useEventObjects: true;
        }, listener: (event: ModelOnEventMap[T], captures: EventObjectCaptures) => void): () => void;
        on(eventType: 'all', options: {
            useEventObjects: true;
        }, listener: (event: ModelEvent, captures: EventObjectCaptures) => void): () => void;
        /**
         * Listen to Racer events matching a certain path or path pattern, removing
         * the listener after it gets triggered once.
         *
         * @param eventType
         * @param pathPattern
         * @param options
         * @param listener
         *
         * @see https://derbyjs.github.io/derby/components/events
         */
        once<T extends keyof ModelOnEventMap>(eventType: T, pathPattern: string, options: {
            useEventObjects: true;
        }, listener: (event: ModelOnEventMap[T], captures: Array<string | string[]>) => void): Function;
        once<T extends keyof ModelOnEventMap>(eventType: T, options: {
            useEventObjects: true;
        }, listener: (event: ModelOnEventMap[T], captures: Array<string | string[]>) => void): Function;
        /**
         * Passes data to event listeners
         *
         * @param object - An object whose properties will each be set on the passed argument
         * @returns back a model scoped to the same path
         */
        pass(object: object, invert?: boolean): Model<T>;
        removeAllListeners(type: string, subpath: Path): void;
        /**
         * Remove all listeners that were registered with this model's event context.
         *
         * @see {@link eventContext}
         */
        removeContextListeners(): void;
        removeListener(eventType: keyof ModelOnEventMap | keyof ModelOnImmediateEventMap | 'all', listener: Function): void;
        setMaxListeners(limit: number): void;
        silent(value?: boolean): Model<T>;
        wrapCallback(cb?: ErrorCallback): ErrorCallback;
        __on: typeof EventEmitter.prototype.on;
        __once: typeof EventEmitter.prototype.once;
        __removeAllListeners: typeof EventEmitter.prototype.removeAllListeners;
        __removeListener: typeof EventEmitter.prototype.removeListener;
        _addMutationListener(type: string, arg1: any, arg2: any, arg3: any): MutationListener;
        _callMutationListeners(type: string, segments: Segments, event: any): void;
        _defaultCallback(err?: Error): void;
        _emitError(err: Error, context?: any): void;
        _emitMutation(segments: Segments, event: any): void;
        _emittingMutation: boolean;
        /**
         * Map of "event context" name to an array of listeners with that event context
         *
         * @see {@link _eventContext}
         */
        _eventContextListeners: Record<string, MutationListener[]>;
        _mutationEventQueue: null;
        /**
         * Map of event type to mutation listener tree for that type
         */
        _mutationListeners: Record<string, EventListenerTree>;
        _removeAllListeners(type: string, segments: Segments): void;
        _removeMutationListener(listener: MutationListener): void;
    }
}
export declare class Passed {
}
declare class MutationListener {
    patternSegments: string[];
    eventContext: any;
    fn: any;
    node: any | null;
    constructor(patternSegments: any, eventContext: any, fn: any);
}
export declare class ChangeEvent {
    type: 'change';
    _immediateType: 'changeImmediate';
    value: any;
    previous: any;
    passed: any;
    constructor(value: any, previous: any, passed: any);
    clone(): ChangeEvent;
    _getArgs(): any[];
}
export declare class LoadEvent {
    type: 'load';
    _immediateType: 'loadImmediate';
    value: any;
    document: any;
    passed: any;
    constructor(value: any, passed: any);
    clone(): LoadEvent;
    _getArgs(): any[];
}
export declare class UnloadEvent {
    type: 'unload';
    _immediateType: 'unloadImmediate';
    previous: any;
    previousDocument: any;
    passed: any;
    constructor(previous: any, passed: any);
    clone(): UnloadEvent;
    _getArgs(): any[];
}
export declare class InsertEvent {
    type: 'insert';
    _immediateType: 'insertImmediate';
    index: number;
    values: any[];
    passed: any;
    constructor(index: any, values: any, passed: any);
    clone(): InsertEvent;
    _getArgs(): any[];
}
export declare class RemoveEvent {
    type: 'remove';
    _immediateType: 'removeImmediate';
    index: number;
    passed: any;
    removed: any[];
    /** @deprecated Use `removed` instead */
    values: any[];
    constructor(index: any, values: any, passed: any);
    clone(): RemoveEvent;
    _getArgs(): any[];
}
export declare class MoveEvent {
    type: 'move';
    _immediateType: 'moveImmediate';
    from: number;
    howMany: number;
    passed: any;
    to: number;
    constructor(from: any, to: any, howMany: any, passed: any);
    clone(): MoveEvent;
    _getArgs(): any[];
}
export declare const mutationEvents: {
    ChangeEvent: typeof ChangeEvent;
    LoadEvent: typeof LoadEvent;
    UnloadEvent: typeof UnloadEvent;
    InsertEvent: typeof InsertEvent;
    RemoveEvent: typeof RemoveEvent;
    MoveEvent: typeof MoveEvent;
};
export {};
