Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = exports.CollectionData = exports.ModelData = exports.ModelCollections = void 0;
var Model_1 = require("./Model");
var LocalDoc = require('./LocalDoc');
var util = require('../util');
var ModelCollections = /** @class */ (function () {
    function ModelCollections() {
    }
    return ModelCollections;
}());
exports.ModelCollections = ModelCollections;
/** Root model data */
var ModelData = /** @class */ (function () {
    function ModelData() {
    }
    return ModelData;
}());
exports.ModelData = ModelData;
var DocMap = /** @class */ (function () {
    function DocMap() {
    }
    return DocMap;
}());
/** Dictionary of document id to document data */
var CollectionData = /** @class */ (function () {
    function CollectionData() {
    }
    return CollectionData;
}());
exports.CollectionData = CollectionData;
Model_1.Model.INITS.push(function (model) {
    model.root.collections = new ModelCollections();
    model.root.data = new ModelData();
});
Model_1.Model.prototype.getCollection = function (collectionName) {
    return this.root.collections[collectionName];
};
Model_1.Model.prototype.getDoc = function (collectionName, id) {
    var collection = this.root.collections[collectionName];
    return collection && collection.docs[id];
};
Model_1.Model.prototype.get = function (subpath) {
    var segments = this._splitPath(subpath);
    return this._get(segments);
};
Model_1.Model.prototype._get = function (segments) {
    return util.lookup(segments, this.root.data);
};
Model_1.Model.prototype.getCopy = function (subpath) {
    var segments = this._splitPath(subpath);
    return this._getCopy(segments);
};
Model_1.Model.prototype._getCopy = function (segments) {
    var value = this._get(segments);
    return util.copy(value);
};
Model_1.Model.prototype.getDeepCopy = function (subpath) {
    var segments = this._splitPath(subpath);
    return this._getDeepCopy(segments);
};
Model_1.Model.prototype._getDeepCopy = function (segments) {
    var value = this._get(segments);
    return util.deepCopy(value);
};
Model_1.Model.prototype.getValues = function (subpath) {
    var value = this.get(subpath);
    if (value == null) {
        return [];
    }
    if (typeof value !== 'object') {
        throw new Error("Found non-object type for getValues('".concat(this.path(subpath), "')"));
    }
    return Object.values(value);
};
Model_1.Model.prototype.getOrCreateCollection = function (name) {
    var collection = this.root.collections[name];
    if (collection)
        return collection;
    var Doc = this._getDocConstructor(name);
    collection = new Collection(this.root, name, Doc);
    this.root.collections[name] = collection;
    return collection;
};
Model_1.Model.prototype._getDocConstructor = function (name) {
    // Only create local documents. This is overriden in ./connection.js, so that
    // the RemoteDoc behavior can be selectively included
    return LocalDoc;
};
/**
 * Returns an existing document with id in a collection. If the document does
 * not exist, then creates the document with id in a collection and returns the
 * new document.
 * @param {String} collectionName
 * @param {String} id
 * @param {Object} [data] data to create if doc with id does not exist in collection
 */
Model_1.Model.prototype.getOrCreateDoc = function (collectionName, id, data) {
    var collection = this.getOrCreateCollection(collectionName);
    return collection.getOrCreateDoc(id, data);
};
Model_1.Model.prototype.getOrDefault = function (subpath, defaultValue) {
    var _a;
    return (_a = this.get(subpath)) !== null && _a !== void 0 ? _a : defaultValue;
};
Model_1.Model.prototype.getOrThrow = function (subpath) {
    var value = this.get(subpath);
    if (value == null) {
        var fullpath = this.path(subpath);
        throw new Error("No value at path ".concat(fullpath));
    }
    return value;
};
/**
 * @param {String} subpath
 */
Model_1.Model.prototype.destroy = function (subpath) {
    var segments = this._splitPath(subpath);
    // Silently remove all types of listeners within subpath
    var silentModel = this.silent();
    silentModel._removeAllListeners(null, segments);
    silentModel._removeAllRefs(segments);
    silentModel._stopAll(segments);
    silentModel._removeAllFilters(segments);
    // Remove listeners created within the model's eventContext and remove the
    // reference to the eventContext
    silentModel.removeContextListeners();
    // Silently remove all model data within subpath
    if (segments.length === 0) {
        this.root.collections = new ModelCollections();
        // Delete each property of data instead of creating a new object so that
        // it is possible to continue using a reference to the original data object
        var data = this.root.data;
        for (var key in data) {
            delete data[key];
        }
    }
    else if (segments.length === 1) {
        var collection = this.getCollection(segments[0]);
        collection && collection.destroy();
    }
    else {
        silentModel._del(segments);
    }
};
var Collection = /** @class */ (function () {
    function Collection(model, name, docClass) {
        this.model = model;
        this.name = name;
        this.Doc = docClass;
        this.size = 0;
        this.docs = new DocMap();
        this.data = model.data[name] = new CollectionData();
    }
    /**
     * Adds a document with `id` and `data` to `this` Collection.
     * @param {String} id
     * @param {Object} data
     * @return {LocalDoc|RemoteDoc} doc
     */
    Collection.prototype.add = function (id, data) {
        var doc = new this.Doc(this.model, this.name, id, data, this);
        this.docs[id] = doc;
        return doc;
    };
    ;
    Collection.prototype.destroy = function () {
        delete this.model.collections[this.name];
        delete this.model.data[this.name];
    };
    ;
    Collection.prototype.getOrCreateDoc = function (id, data) {
        var doc = this.docs[id];
        if (doc)
            return doc;
        this.size++;
        return this.add(id, data);
    };
    ;
    /**
     * Removes the document with `id` from `this` Collection. If there are no more
     * documents in the Collection after the given document is removed, then this
     * destroys the Collection.
     *
     * @param {String} id
     */
    Collection.prototype.remove = function (id) {
        if (!this.docs[id])
            return;
        this.size--;
        if (this.size > 0) {
            delete this.docs[id];
            delete this.data[id];
        }
        else {
            this.destroy();
        }
    };
    return Collection;
}());
exports.Collection = Collection;
;
