/// <reference types="node" />
import { EventEmitter } from 'events';
import { RootModel } from 'racer';
import { AppForClient } from '../App';
import { Component, ComponentConstructor } from '../components';
import { PageForClient } from '../Page';
export interface RenderOptions {
    url?: string;
}
export declare class PageForHarness extends PageForClient {
    component?: Component;
    fragment?: DocumentFragment;
    html?: string;
}
interface PageRenderedHtml extends PageForHarness {
    html: string;
    fragment: undefined;
}
interface PageRenderedFragment extends PageForHarness {
    html: undefined;
    fragment: DocumentFragment;
}
export declare class AppForHarness extends AppForClient {
    _harness: any;
    _pages: PageForHarness[];
    page: PageForHarness;
    Page: typeof PageForHarness;
    constructor(harness: any);
    createPage(): PageForHarness;
    loadViews(...args: any[]): void;
    _init(): void;
    _initLoad(): void;
}
/**
 * Creates a `ComponentHarness`.
 *
 * If arguments are provided, then `#setup` is called with the arguments.
 */
export declare class ComponentHarness extends EventEmitter {
    app: AppForHarness;
    document: Document;
    model: RootModel;
    page: PageForHarness;
    /**
     * Creates a `ComponentHarness`.
     *
     * If arguments are provided, then `#setup` is called with the arguments.
     */
    constructor();
    /** @typedef { {view: {is: string, source?: string}} } InlineComponent */
    /**
     * Sets up the harness with a HTML template, which should contain a `<view is="..."/>` for the
     * component under test, and the components to register for the test.
     *
     * @param {string} source - HTML template for the harness page
     * @param {...(Component | InlineComponent} components - components to register for the test
     *
     * @example
     *   var harness = new ComponentHarness().setup('<view is="dialog"/>', Dialog);
     */
    setup(source: string, ...components: ComponentConstructor[]): this;
    /**
     * Stubs out view names with empty view or the provided source.
     *
     * A view name is a colon-separated string of segments, as used in `<view is="...">`.
     *
     * @example
     *   var harness = new ComponentHarness('<view is="dialog"/>', Dialog).stub(
     *     'icons:open-icon',
     *     'icons:close-icon',
     *     {is: 'dialog:buttons', source: '<button>OK</button>'}
     *   );
     */
    stub(...args: Array<string | {
        is: string;
        source?: string;
    }>): this;
    /**
     * Stubs out view names as components.
     *
     * This can be used to test the values being bound to ("passed into") child components.
     *
     * @example
     *   var harness = new ComponentHarness('<view is="dialog"/>', Dialog)
     *     .stubComponent('common:file-picker', {is: 'footer', as: 'stubFooter'});
     */
    stubComponent(...args: Array<string | {
        is: string;
    }>): this;
    /**
     * @typedef {Object} RenderOptions
     * @property {string} [url] - Optional URL for the render, used to populate `page.params`
     */
    /**
     * Renders the harness into a HTML string, as server-side rendering would do.
     *
     * @param {RenderOptions} [options]
     * @returns { Page & {html: string} } - a `Page` that has a `html` property with the rendered HTML
     *   string
     */
    renderHtml(options?: RenderOptions): PageRenderedHtml;
    /**
     * Renders the harness into a `DocumentFragment`, as client-side rendering would do.
     *
     * @param {RenderOptions} [options]
     * @returns { Page & {fragment: DocumentFragment} } a `Page` that has a `fragment` property with the
     *   rendered `DocumentFragment`
     */
    renderDom(options?: RenderOptions): PageRenderedFragment;
    attachTo(parentNode: any, node: any): PageForHarness;
    /**
     * @param {(page: PageForHarness) => void} render
     * @param {RenderOptions} [options]
     */
    _get(renderFn: (page: PageForHarness) => void, options?: RenderOptions): PageForHarness;
    /**
     * Instantiates a component and calls its `init()` if present, without rendering it.
     *
     * This can be used in place of `new MyComponent()` in old tests that were written prior to the
     * component test framework being developed.
     *
     * @param Ctor - class (constructor) for the component to instantiate
     * @param rootModel - a root model
     * @returns a newly instantiated component, with its `init()` already called if present
     */
    createNonRenderedComponent(Ctor: ComponentConstructor, rootModel: RootModel): any;
    static createStubComponent(options: any): ComponentConstructor;
}
export {};
