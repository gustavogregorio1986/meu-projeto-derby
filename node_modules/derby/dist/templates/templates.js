var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.elementRemoveDestroyListener = exports.elementAddDestroyListener = exports.AsArrayComponent = exports.AsArray = exports.AsObjectComponent = exports.AsObject = exports.AsPropertyComponent = exports.AsProperty = exports.ComponentOn = exports.ElementOn = exports.Views = exports.ContextClosure = exports.ViewParent = exports.DynamicViewInstance = exports.ViewInstance = exports.View = exports.Marker = exports.MarkupHook = exports.emptyTemplate = exports.RangeBinding = exports.AttributeBinding = exports.AttributeBindingsMap = exports.NodeBinding = exports.Binding = exports.EachBlock = exports.ConditionalBlock = exports.Block = exports.DynamicElement = exports.Element = exports.DynamicAttribute = exports.Attribute = exports.DynamicHtml = exports.Html = exports.DynamicComment = exports.Comment = exports.DynamicText = exports.Text = exports.Doctype = exports.Template = exports.NAMESPACE_URIS = exports.VOID_ELEMENTS = exports.CREATE_PROPERTIES = exports.UPDATE_PROPERTIES = exports.STRING_PROPERTIES = exports.INTEGER_PROPERTIES = exports.BOOLEAN_PROPERTIES = void 0;
var serializeObject;
if (typeof require === 'function') {
    serializeObject = require('serialize-object');
}
var dependencyOptions_1 = require("./dependencyOptions");
var util_1 = require("./util");
// namespace these are exported under; used when serializing views
var NAMESPACE = 'templates';
// UPDATE_PROPERTIES map HTML attribute names to an Element DOM property that
// should be used for setting on bindings updates instead of setAttribute.
//
// https://github.com/jquery/jquery/blob/1.x-master/src/attributes/prop.js
// https://github.com/jquery/jquery/blob/master/src/attributes/prop.js
// http://webbugtrack.blogspot.com/2007/08/bug-242-setattribute-doesnt-always-work.html
exports.BOOLEAN_PROPERTIES = {
    checked: 'checked',
    disabled: 'disabled',
    indeterminate: 'indeterminate',
    readonly: 'readOnly',
    selected: 'selected'
};
exports.INTEGER_PROPERTIES = {
    colspan: 'colSpan',
    maxlength: 'maxLength',
    rowspan: 'rowSpan',
    tabindex: 'tabIndex'
};
exports.STRING_PROPERTIES = {
    cellpadding: 'cellPadding',
    cellspacing: 'cellSpacing',
    'class': 'className',
    contenteditable: 'contentEditable',
    enctype: 'encoding',
    'for': 'htmlFor',
    frameborder: 'frameBorder',
    id: 'id',
    title: 'title',
    type: 'type',
    usemap: 'useMap',
    value: 'value'
};
exports.UPDATE_PROPERTIES = __assign(__assign(__assign({}, exports.BOOLEAN_PROPERTIES), exports.INTEGER_PROPERTIES), exports.STRING_PROPERTIES);
// CREATE_PROPERTIES map HTML attribute names to an Element DOM property that
// should be used for setting on Element rendering instead of setAttribute.
// input.defaultChecked and input.defaultValue affect the attribute, so we want
// to use these for initial dynamic rendering. For binding updates,
// input.checked and input.value are modified.
exports.CREATE_PROPERTIES = __assign(__assign({}, exports.UPDATE_PROPERTIES), { checked: 'defaultChecked', value: 'defaultValue' });
// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
exports.VOID_ELEMENTS = {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    menuitem: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
};
exports.NAMESPACE_URIS = {
    svg: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink',
    xmlns: 'http://www.w3.org/2000/xmlns/'
};
var Template = /** @class */ (function () {
    function Template(content, source) {
        this.module = NAMESPACE;
        this.type = 'Template';
        this.content = content;
        this.source = source;
    }
    Template.prototype.toString = function () {
        return this.source;
    };
    Template.prototype.get = function (context, unescaped) {
        return contentHtml(this.content, context, unescaped);
    };
    Template.prototype.getFragment = function (context, binding) {
        var fragment = document.createDocumentFragment();
        this.appendTo(fragment, context, binding);
        return fragment;
    };
    Template.prototype.appendTo = function (parent, context, _binding) {
        context.pause();
        appendContent(parent, this.content, context);
        context.unpause();
    };
    Template.prototype.attachTo = function (parent, node, context) {
        context.pause();
        node = attachContent(parent, node, this.content, context);
        context.unpause();
        return node;
    };
    Template.prototype.update = function (_context, _binding) { };
    Template.prototype.stringify = function (value) {
        return (value == null) ? '' : value + '';
    };
    Template.prototype.equals = function (other) {
        return this === other;
    };
    Template.prototype.serialize = function () {
        return serializeObject.instance(this, this.content, this.source);
    };
    Template.prototype.isUnbound = function (context) {
        return context.unbound;
    };
    Template.prototype.resolve = function (_context) { };
    Template.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        return concatArrayDependencies(null, this.content, context, options);
    };
    return Template;
}());
exports.Template = Template;
var Doctype = /** @class */ (function (_super) {
    __extends(Doctype, _super);
    function Doctype(name, publicId, systemId) {
        var _this = _super.call(this) || this;
        _this.type = 'Doctype';
        _this.name = name;
        _this.publicId = publicId;
        _this.systemId = systemId;
        return _this;
    }
    Doctype.prototype.get = function () {
        var publicText = (this.publicId) ?
            ' PUBLIC "' + this.publicId + '"' :
            '';
        var systemText = (this.systemId) ?
            (this.publicId) ?
                ' "' + this.systemId + '"' :
                ' SYSTEM "' + this.systemId + '"' :
            '';
        return '<!DOCTYPE ' + this.name + publicText + systemText + '>';
    };
    Doctype.prototype.appendTo = function () {
        // Doctype could be created via:
        //   document.implementation.createDocumentType(this.name, this.publicId, this.systemId)
        // However, it does not appear possible or useful to append it to the
        // document fragment. Therefore, just don't render it in the browser
    };
    Doctype.prototype.attachTo = function (parent, node) {
        if (!hasNodeType(node, 10)) {
            throw attachError(parent, node);
        }
        return node.nextSibling;
    };
    Doctype.prototype.serialize = function () {
        return serializeObject.instance(this, this.name, this.publicId, this.systemId);
    };
    Doctype.prototype.dependencies = function () { return undefined; };
    return Doctype;
}(Template));
exports.Doctype = Doctype;
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text(data) {
        var _this = _super.call(this) || this;
        _this.type = 'Text';
        _this.data = data;
        _this.escaped = escapeHtml(data);
        return _this;
    }
    Text.prototype.get = function (context, unescaped) {
        return (unescaped) ? this.data : this.escaped;
    };
    Text.prototype.appendTo = function (parent) {
        var node = document.createTextNode(this.data);
        parent.appendChild(node);
    };
    Text.prototype.attachTo = function (parent, node) {
        return attachText(parent, node, this.data, this);
    };
    Text.prototype.serialize = function () {
        return serializeObject.instance(this, this.data);
    };
    Text.prototype.dependencies = function () { return undefined; };
    return Text;
}(Template));
exports.Text = Text;
// DynamicText might be more accurately named DynamicContent. When its
// expression returns a template, it acts similar to a Block, and it renders
// the template surrounded by comment markers for range replacement. When its
// expression returns any other type, it renders a DOM Text node with no
// markers. Text nodes are bound by updating their data property dynamically.
// The update method must take care to switch between these types of bindings
// in case the expression return type changes dynamically.
var DynamicText = /** @class */ (function (_super) {
    __extends(DynamicText, _super);
    function DynamicText(expression) {
        var _this = _super.call(this) || this;
        _this.type = 'DynamicText';
        _this._blockUpdate = Block.prototype.update;
        _this.expression = expression;
        _this.unbound = false;
        return _this;
    }
    DynamicText.prototype.get = function (context, unescaped) {
        var value = this.expression.get(context);
        if (value instanceof Template) {
            do {
                value = value.get(context, unescaped);
            } while (value instanceof Template);
            return value;
        }
        var data = this.stringify(value);
        return (unescaped) ? data : escapeHtml(data);
    };
    DynamicText.prototype.appendTo = function (parent, context, binding) {
        var value = this.expression.get(context);
        if (value instanceof Template) {
            var start = document.createComment(this.expression.toString());
            var end = document.createComment('/' + this.expression);
            var condition = this.getCondition(context);
            parent.appendChild(start);
            value.appendTo(parent, context);
            parent.appendChild(end);
            updateRange(context, binding, this, start, end, null, condition);
            return;
        }
        var data = this.stringify(value);
        var node = document.createTextNode(data);
        parent.appendChild(node);
        addNodeBinding(this, context, node);
    };
    DynamicText.prototype.attachTo = function (parent, node, context) {
        var value = this.expression.get(context);
        if (value instanceof Template) {
            var start = document.createComment(this.expression.toString());
            var end = document.createComment('/' + this.expression);
            var condition = this.getCondition(context);
            parent.insertBefore(start, node || null);
            node = value.attachTo(parent, node, context);
            parent.insertBefore(end, node || null);
            updateRange(context, null, this, start, end, null, condition);
            return node;
        }
        var data = this.stringify(value);
        return attachText(parent, node, data, this, context);
    };
    DynamicText.prototype.update = function (context, binding) {
        if (binding instanceof RangeBinding) {
            this._blockUpdate(context, binding);
            return;
        }
        if (!(binding instanceof NodeBinding)) {
            // TODO: Confirm this won't ever happen in practice.
            throw new Error('DynamicText must be bound with a NodeBinding');
        }
        var value = this.expression.get(context);
        if (value instanceof Template) {
            var start = binding.node;
            if (!start.parentNode)
                return;
            var end = start;
            var fragment = this.getFragment(context);
            replaceRange(context, start, end, fragment, binding);
            return;
        }
        binding.node.data = this.stringify(value);
    };
    DynamicText.prototype.getCondition = function (context) {
        return this.expression.get(context);
    };
    DynamicText.prototype.serialize = function () {
        return serializeObject.instance(this, this.expression);
    };
    DynamicText.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        return getDependencies(this.expression, context, options);
    };
    return DynamicText;
}(Template));
exports.DynamicText = DynamicText;
function attachText(parent, node, data, template, context) {
    if (!node) {
        var newNode = document.createTextNode(data);
        parent.appendChild(newNode);
        addNodeBinding(template, context, newNode);
        return;
    }
    if (hasNodeType(node, 3)) {
        // Proceed if nodes already match
        if (node.data === data) {
            addNodeBinding(template, context, node);
            return node.nextSibling;
        }
        data = normalizeLineBreaks(data);
        // Split adjacent text nodes that would have been merged together in HTML
        var nextNode = splitData(node, data.length);
        if (node.data !== data) {
            throw attachError(parent, node);
        }
        addNodeBinding(template, context, node);
        return nextNode;
    }
    // An empty text node might not be created at the end of some text
    if (data === '') {
        var newNode = document.createTextNode('');
        parent.insertBefore(newNode, node || null);
        addNodeBinding(template, context, newNode);
        return node;
    }
    throw attachError(parent, node);
}
var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(data, hooks) {
        var _this = _super.call(this) || this;
        _this.type = 'Comment';
        _this.data = data;
        _this.hooks = hooks;
        return _this;
    }
    Comment.prototype.get = function () {
        return '<!--' + this.data + '-->';
    };
    Comment.prototype.appendTo = function (parent, context) {
        var node = document.createComment(this.data);
        parent.appendChild(node);
        emitHooks(this.hooks, context, node);
    };
    Comment.prototype.attachTo = function (parent, node, context) {
        return attachComment(parent, node, this.data, this, context);
    };
    Comment.prototype.serialize = function () {
        return serializeObject.instance(this, this.data, this.hooks);
    };
    Comment.prototype.dependencies = function () { return undefined; };
    return Comment;
}(Template));
exports.Comment = Comment;
var DynamicComment = /** @class */ (function (_super) {
    __extends(DynamicComment, _super);
    function DynamicComment(expression, hooks) {
        var _this = _super.call(this) || this;
        _this.type = 'DynamicComment';
        _this.expression = expression;
        _this.hooks = hooks;
        return _this;
    }
    DynamicComment.prototype.get = function (context) {
        var value = getUnescapedValue(this.expression, context);
        var data = this.stringify(value);
        return '<!--' + data + '-->';
    };
    DynamicComment.prototype.appendTo = function (parent, context) {
        var value = getUnescapedValue(this.expression, context);
        var data = this.stringify(value);
        var node = document.createComment(data);
        parent.appendChild(node);
        addNodeBinding(this, context, node);
    };
    DynamicComment.prototype.attachTo = function (parent, node, context) {
        var value = getUnescapedValue(this.expression, context);
        var data = this.stringify(value);
        return attachComment(parent, node, data, this, context);
    };
    DynamicComment.prototype.update = function (context, binding) {
        var value = getUnescapedValue(this.expression, context);
        binding.node.data = this.stringify(value);
    };
    DynamicComment.prototype.serialize = function () {
        return serializeObject.instance(this, this.expression, this.hooks);
    };
    DynamicComment.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        return getDependencies(this.expression, context, options);
    };
    return DynamicComment;
}(Template));
exports.DynamicComment = DynamicComment;
function attachComment(parent, node, data, template, context) {
    // Sometimes IE fails to create Comment nodes from HTML or innerHTML.
    // This is an issue inside of <select> elements, for example.
    if (!hasNodeType(node, 8)) {
        var newNode = document.createComment(data);
        parent.insertBefore(newNode, node || null);
        addNodeBinding(template, context, newNode);
        return node;
    }
    // Proceed if nodes already match
    if (node.data === data) {
        addNodeBinding(template, context, node);
        return node.nextSibling;
    }
    throw attachError(parent, node);
}
function addNodeBinding(template, context, node) {
    if (template.expression && !template.unbound) {
        context.addBinding(new NodeBinding(template, context, node));
    }
    emitHooks(template.hooks, context, node);
}
var Html = /** @class */ (function (_super) {
    __extends(Html, _super);
    function Html(data) {
        var _this = _super.call(this) || this;
        _this.type = 'Html';
        _this.data = data;
        return _this;
    }
    Html.prototype.get = function () {
        return this.data;
    };
    Html.prototype.appendTo = function (parent) {
        var fragment = createHtmlFragment(parent, this.data);
        parent.appendChild(fragment);
    };
    Html.prototype.attachTo = function (parent, node) {
        return attachHtml(parent, node, this.data);
    };
    Html.prototype.serialize = function () {
        return serializeObject.instance(this, this.data);
    };
    Html.prototype.dependencies = function () { return undefined; };
    return Html;
}(Template));
exports.Html = Html;
var DynamicHtml = /** @class */ (function (_super) {
    __extends(DynamicHtml, _super);
    function DynamicHtml(expression) {
        var _this = _super.call(this) || this;
        _this.type = 'DynamicHtml';
        _this.expression = expression;
        _this.ending = '/' + expression;
        return _this;
    }
    DynamicHtml.prototype.get = function (context) {
        var value = getUnescapedValue(this.expression, context);
        return this.stringify(value);
    };
    DynamicHtml.prototype.appendTo = function (parent, context, binding) {
        var start = document.createComment(this.expression.toString());
        var end = document.createComment(this.ending);
        var value = getUnescapedValue(this.expression, context);
        var html = this.stringify(value);
        var fragment = createHtmlFragment(parent, html);
        parent.appendChild(start);
        parent.appendChild(fragment);
        parent.appendChild(end);
        updateRange(context, binding, this, start, end);
    };
    DynamicHtml.prototype.attachTo = function (parent, node, context) {
        var start = document.createComment(this.expression.toString());
        var end = document.createComment(this.ending);
        var value = getUnescapedValue(this.expression, context);
        var html = this.stringify(value);
        parent.insertBefore(start, node || null);
        node = attachHtml(parent, node, html);
        parent.insertBefore(end, node || null);
        updateRange(context, null, this, start, end);
        return node;
    };
    DynamicHtml.prototype.update = function (context, binding) {
        var parent = binding.start.parentNode;
        if (!parent)
            return;
        // Get start and end in advance, since binding is mutated in getFragment
        var start = binding.start;
        var end = binding.end;
        var value = getUnescapedValue(this.expression, context);
        var html = this.stringify(value);
        var fragment = createHtmlFragment(parent, html);
        var innerOnly = true;
        replaceRange(context, start, end, fragment, binding, innerOnly);
    };
    DynamicHtml.prototype.serialize = function () {
        return serializeObject.instance(this, this.expression);
    };
    DynamicHtml.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        return getDependencies(this.expression, context, options);
    };
    return DynamicHtml;
}(Template));
exports.DynamicHtml = DynamicHtml;
function createHtmlFragment(parent, html) {
    if (hasNodeType(parent, 1)) {
        var range_1 = document.createRange();
        range_1.selectNodeContents(parent);
        return range_1.createContextualFragment(html);
    }
    var div = document.createElement('div');
    var range = document.createRange();
    div.innerHTML = html;
    range.selectNodeContents(div);
    return range.extractContents();
}
function attachHtml(parent, node, html) {
    var fragment = createHtmlFragment(parent, html);
    for (var i = 0, len = fragment.childNodes.length; i < len; i++) {
        if (!node)
            throw attachError(parent, node);
        node = node.nextSibling;
    }
    return node;
}
var Attribute = /** @class */ (function (_super) {
    __extends(Attribute, _super);
    function Attribute(data, ns) {
        var _this = _super.call(this) || this;
        _this.type = 'Attribute';
        _this.data = data;
        _this.ns = ns;
        return _this;
    }
    Attribute.prototype.get = function (_context) {
        return this.data;
    };
    Attribute.prototype.getBound = function (_context, _element, _name, _elementNs) {
        return this.get();
    };
    Attribute.prototype.serialize = function () {
        return serializeObject.instance(this, this.data, this.ns);
    };
    Attribute.prototype.dependencies = function (_context, _options) { return undefined; };
    return Attribute;
}(Template));
exports.Attribute = Attribute;
var DynamicAttribute = /** @class */ (function (_super) {
    __extends(DynamicAttribute, _super);
    function DynamicAttribute(expression, ns) {
        var _this = _super.call(this, null, ns) || this;
        _this.type = 'DynamicAttribute';
        // In attributes, expression may be an instance of Template or Expression
        _this.expression = expression;
        _this.elementNs = null;
        return _this;
    }
    DynamicAttribute.prototype.get = function (context) {
        return getUnescapedValue(this.expression, context);
    };
    DynamicAttribute.prototype.getBound = function (context, element, name, elementNs) {
        this.elementNs = elementNs;
        context.addBinding(new AttributeBinding(this, context, element, name));
        return getUnescapedValue(this.expression, context);
    };
    DynamicAttribute.prototype.update = function (context, binding) {
        var value = getUnescapedValue(this.expression, context);
        var element = binding.element;
        var propertyName = !this.elementNs && exports.UPDATE_PROPERTIES[binding.name];
        if (propertyName) {
            // Update via DOM property, short-circuiting if no update is needed.
            // Certain properties must be strings, so for those properties, the value gets stringified.
            //
            // There is one special case, when updating the string `input.value` property with a number.
            // If a user tries to type "1.01" in an `<input type="number">, then once they've typed "1.0",
            // the context value is set to `1`, triggering this update function to set the input value to
            // "1". That means typing "1.01" would be impossible without special handling to avoid
            // overwriting an existing input value of "1.0" with a new value of "1".
            if (element.tagName === 'INPUT' && propertyName === 'value' && typeof value === 'number') {
                if (parseFloat(element.value) === value) {
                    return;
                }
            }
            var propertyValue = (exports.STRING_PROPERTIES[binding.name]) ?
                this.stringify(value) : value;
            if (element[propertyName] === propertyValue)
                return;
            element[propertyName] = propertyValue;
            return;
        }
        if (value === false || value == null) {
            if (this.ns) {
                element.removeAttributeNS(this.ns, binding.name);
            }
            else {
                element.removeAttribute(binding.name);
            }
            return;
        }
        if (value === true)
            value = binding.name;
        if (this.ns) {
            element.setAttributeNS(this.ns, binding.name, value);
        }
        else {
            element.setAttribute(binding.name, value);
        }
    };
    DynamicAttribute.prototype.serialize = function () {
        return serializeObject.instance(this, this.expression, this.ns);
    };
    DynamicAttribute.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        return getDependencies(this.expression, context, options);
    };
    return DynamicAttribute;
}(Attribute));
exports.DynamicAttribute = DynamicAttribute;
function getUnescapedValue(expression, context) {
    var unescaped = true;
    var value = expression.get(context, unescaped);
    while (value instanceof Template) {
        value = value.get(context, unescaped);
    }
    return value;
}
var BaseElement = /** @class */ (function (_super) {
    __extends(BaseElement, _super);
    function BaseElement(attributes, content, hooks, selfClosing, notClosed, ns) {
        var _this = _super.call(this) || this;
        _this.attributes = attributes;
        _this.content = content;
        _this.hooks = hooks;
        _this.selfClosing = selfClosing;
        _this.notClosed = notClosed;
        _this.ns = ns;
        return _this;
    }
    BaseElement.prototype.get = function (context) {
        var tagName = this.getTagName(context);
        var endTag = this.getEndTag(tagName);
        var tagItems = [tagName];
        for (var key in this.attributes) {
            var value = this.attributes[key].get(context);
            if (value === true) {
                tagItems.push(key);
            }
            else if (value !== false && value != null) {
                tagItems.push(key + '="' + escapeAttribute(value) + '"');
            }
        }
        var startTag = '<' + tagItems.join(' ') + this.startClose;
        if (this.content) {
            var inner = contentHtml(this.content, context, this.unescapedContent);
            return startTag + inner + endTag;
        }
        return startTag + endTag;
    };
    BaseElement.prototype.appendTo = function (parent, context) {
        var tagName = this.getTagName(context);
        var element = (this.ns) ?
            document.createElementNS(this.ns, tagName) :
            document.createElement(tagName);
        for (var key in this.attributes) {
            var attribute = this.attributes[key];
            var value = attribute.getBound(context, element, key, this.ns);
            if (value === false || value == null)
                continue;
            var propertyName = !this.ns && exports.CREATE_PROPERTIES[key];
            if (propertyName) {
                element[propertyName] = value;
                continue;
            }
            if (value === true)
                value = key;
            if (attribute.ns) {
                element.setAttributeNS(attribute.ns, key, value);
            }
            else {
                element.setAttribute(key, value);
            }
        }
        if (this.content) {
            this._bindContent(context, element);
            appendContent(element, this.content, context);
        }
        parent.appendChild(element);
        emitHooks(this.hooks, context, element);
    };
    BaseElement.prototype.attachTo = function (parent, node, context) {
        var tagName = this.getTagName(context);
        if (!hasNodeType(node, 1) ||
            node.tagName.toLowerCase() !== tagName.toLowerCase()) {
            throw attachError(parent, node);
        }
        for (var key in this.attributes) {
            // Get each attribute to create bindings
            this.attributes[key].getBound(context, node, key, this.ns);
            // TODO: Ideally, this would also check that the node's current attributes
            // are equivalent, but there are some tricky edge cases
        }
        if (this.content) {
            this._bindContent(context, node);
            attachContent(node, node.firstChild, this.content, context);
        }
        emitHooks(this.hooks, context, node);
        return node.nextSibling;
    };
    BaseElement.prototype._bindContent = function (context, element) {
        // For textareas with dynamic text content, bind to the value property
        var child = this.bindContentToValue &&
            this.content.length === 1 &&
            this.content[0];
        if (child instanceof DynamicText) {
            child.unbound = true;
            var template = new DynamicAttribute(child.expression);
            context.addBinding(new AttributeBinding(template, context, element, 'value'));
        }
    };
    BaseElement.prototype.serialize = function () {
        return serializeObject.instance(this, this.tagName, this.attributes, this.content, this.hooks, this.selfClosing, this.notClosed, this.ns);
    };
    BaseElement.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var dependencies = concatMapDependencies(null, this.attributes, context, options);
        if (!this.content)
            return dependencies;
        return concatArrayDependencies(dependencies, this.content, context, options);
    };
    return BaseElement;
}(Template));
var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    function Element(tagName, attributes, content, hooks, selfClosing, notClosed, ns) {
        var _this = _super.call(this, attributes, content, hooks, selfClosing, notClosed, ns) || this;
        _this.type = 'Element';
        _this.tagName = tagName;
        _this.endTag = getEndTag(tagName, selfClosing, notClosed);
        _this.startClose = getStartClose(selfClosing);
        var lowerTagName = tagName && tagName.toLowerCase();
        _this.unescapedContent = (lowerTagName === 'script' || lowerTagName === 'style');
        _this.bindContentToValue = (lowerTagName === 'textarea');
        return _this;
    }
    Element.prototype.getTagName = function (_context) {
        return this.tagName;
    };
    Element.prototype.getEndTag = function (_tagName) {
        return this.endTag;
    };
    return Element;
}(BaseElement));
exports.Element = Element;
var DynamicElement = /** @class */ (function (_super) {
    __extends(DynamicElement, _super);
    function DynamicElement(tagName, attributes, content, hooks, selfClosing, notClosed, ns) {
        var _this = _super.call(this, attributes, content, hooks, selfClosing, notClosed, ns) || this;
        _this.type = 'DynamicElement';
        _this.content = content;
        _this.attributes = attributes;
        _this.startClose = getStartClose(selfClosing);
        _this.unescapedContent = false;
        _this.tagName = tagName;
        return _this;
    }
    DynamicElement.prototype.getTagName = function (context) {
        return getUnescapedValue(this.tagName, context);
    };
    DynamicElement.prototype.getEndTag = function (tagName) {
        return getEndTag(tagName, this.selfClosing, this.notClosed);
    };
    DynamicElement.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var dependencies = _super.prototype.dependencies.call(this, context, options);
        return concatDependencies(dependencies, this.tagName, context, options);
    };
    return DynamicElement;
}(BaseElement));
exports.DynamicElement = DynamicElement;
function getStartClose(selfClosing) {
    return (selfClosing) ? ' />' : '>';
}
function getEndTag(tagName, selfClosing, notClosed) {
    var lowerTagName = tagName && tagName.toLowerCase();
    var isVoid = exports.VOID_ELEMENTS[lowerTagName];
    return (isVoid || selfClosing || notClosed) ? '' : '</' + tagName + '>';
}
function emitHooks(hooks, context, value) {
    if (!hooks)
        return;
    context.queue(function queuedHooks() {
        for (var i = 0, len = hooks.length; i < len; i++) {
            hooks[i].emit(context, value);
        }
    });
}
var BaseBlock = /** @class */ (function (_super) {
    __extends(BaseBlock, _super);
    function BaseBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BaseBlock;
}(Template));
var Block = /** @class */ (function (_super) {
    __extends(Block, _super);
    function Block(expression, content) {
        var _this = _super.call(this) || this;
        _this.type = 'Block';
        _this.expression = expression;
        _this.ending = '/' + expression;
        _this.content = content;
        return _this;
    }
    Block.prototype.get = function (context, unescaped) {
        var blockContext = context.child(this.expression);
        return contentHtml(this.content, blockContext, unescaped);
    };
    Block.prototype.appendTo = function (parent, context, binding) {
        var blockContext = context.child(this.expression);
        var start = document.createComment(this.expression.toString());
        var end = document.createComment(this.ending);
        var condition = this.getCondition(context);
        parent.appendChild(start);
        appendContent(parent, this.content, blockContext);
        parent.appendChild(end);
        updateRange(context, binding, this, start, end, null, condition);
    };
    Block.prototype.attachTo = function (parent, node, context) {
        var blockContext = context.child(this.expression);
        var start = document.createComment(this.expression.toString());
        var end = document.createComment(this.ending);
        var condition = this.getCondition(context);
        parent.insertBefore(start, node || null);
        node = attachContent(parent, node, this.content, blockContext);
        parent.insertBefore(end, node || null);
        updateRange(context, null, this, start, end, null, condition);
        return node;
    };
    Block.prototype.serialize = function () {
        return serializeObject.instance(this, this.expression, this.content);
    };
    Block.prototype.update = function (context, binding) {
        if (!binding.start.parentNode)
            return;
        var condition = this.getCondition(context);
        // Cancel update if prior condition is equivalent to current value
        if (equalConditions(condition, binding.condition))
            return;
        binding.condition = condition;
        // Get start and end in advance, since binding is mutated in getFragment
        var start = binding.start;
        var end = binding.end;
        var fragment = this.getFragment(context, binding);
        replaceRange(context, start, end, fragment, binding);
    };
    Block.prototype.getCondition = function (context) {
        // We do an identity check to see if the value has changed before updating.
        // With objects, the object would still be the same, so this identity check
        // would fail to update enough. Thus, return NaN, which never equals anything
        // including itself, so that we always update on objects.
        //
        // We could also JSON stringify or use some other hashing approach. However,
        // that could be really expensive on gets of things that never change, and
        // is probably not a good tradeoff. Perhaps there should be a separate block
        // type that is only used in the case of dynamic updates
        var value = this.expression.get(context);
        return (typeof value === 'object') ? NaN : value;
    };
    Block.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var dependencies = (this.expression.meta && this.expression.meta.blockType === 'on') ?
            getDependencies(this.expression, context, options) : null;
        var blockContext = context.child(this.expression);
        return concatArrayDependencies(dependencies, this.content, blockContext, options);
    };
    return Block;
}(BaseBlock));
exports.Block = Block;
var ConditionalBlock = /** @class */ (function (_super) {
    __extends(ConditionalBlock, _super);
    // @TODO: resolve expressions and contents (plural) with Block super call
    function ConditionalBlock(expressions, contents) {
        var _this = _super.call(this) || this;
        _this.type = 'ConditionalBlock';
        _this.expressions = expressions;
        _this.beginning = expressions.join('; ');
        _this.ending = '/' + _this.beginning;
        _this.contents = contents;
        return _this;
    }
    ConditionalBlock.prototype.get = function (context, unescaped) {
        var condition = this.getCondition(context);
        if (condition == null)
            return '';
        var expression = this.expressions[condition];
        var blockContext = context.child(expression);
        return contentHtml(this.contents[condition], blockContext, unescaped);
    };
    ConditionalBlock.prototype.appendTo = function (parent, context, binding) {
        var start = document.createComment(this.beginning);
        var end = document.createComment(this.ending);
        parent.appendChild(start);
        var condition = this.getCondition(context);
        if (condition != null) {
            var expression = this.expressions[condition];
            var blockContext = context.child(expression);
            appendContent(parent, this.contents[condition], blockContext);
        }
        parent.appendChild(end);
        updateRange(context, binding, this, start, end, null, condition);
    };
    ConditionalBlock.prototype.attachTo = function (parent, node, context) {
        var start = document.createComment(this.beginning);
        var end = document.createComment(this.ending);
        parent.insertBefore(start, node || null);
        var condition = this.getCondition(context);
        if (condition != null) {
            var expression = this.expressions[condition];
            var blockContext = context.child(expression);
            node = attachContent(parent, node, this.contents[condition], blockContext);
        }
        parent.insertBefore(end, node || null);
        updateRange(context, null, this, start, end, null, condition);
        return node;
    };
    ConditionalBlock.prototype.serialize = function () {
        return serializeObject.instance(this, this.expressions, this.contents);
    };
    ConditionalBlock.prototype.update = function (context, binding) {
        if (!binding.start.parentNode)
            return;
        var condition = this.getCondition(context);
        // Cancel update if prior condition is equivalent to current value
        if (equalConditions(condition, binding.condition))
            return;
        binding.condition = condition;
        // Get start and end in advance, since binding is mutated in getFragment
        var start = binding.start;
        var end = binding.end;
        var fragment = this.getFragment(context, binding);
        replaceRange(context, start, end, fragment, binding);
    };
    ConditionalBlock.prototype.getCondition = function (context) {
        for (var i = 0, len = this.expressions.length; i < len; i++) {
            if (this.expressions[i].truthy(context)) {
                return i;
            }
        }
    };
    ConditionalBlock.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var condition = this.getCondition(context);
        if (condition == null) {
            return getDependencies(this.expressions[0], context, options);
        }
        var dependencies = concatSubArrayDependencies(null, this.expressions, context, options, condition);
        var expression = this.expressions[condition];
        var content = this.contents[condition];
        var blockContext = context.child(expression);
        return concatArrayDependencies(dependencies, content, blockContext, options);
    };
    return ConditionalBlock;
}(BaseBlock));
exports.ConditionalBlock = ConditionalBlock;
var EachBlock = /** @class */ (function (_super) {
    __extends(EachBlock, _super);
    function EachBlock(expression, content, elseContent) {
        var _this = _super.call(this, expression, content) || this;
        _this.type = 'EachBlock';
        _this.ending = '/' + expression;
        _this.elseContent = elseContent;
        return _this;
    }
    EachBlock.prototype.get = function (context, unescaped) {
        var items = this.expression.get(context);
        if (items && items.length) {
            var html = '';
            for (var i = 0, len = items.length; i < len; i++) {
                var itemContext = context.eachChild(this.expression, i);
                html += contentHtml(this.content, itemContext, unescaped);
            }
            return html;
        }
        else if (this.elseContent) {
            return contentHtml(this.elseContent, context, unescaped);
        }
        return '';
    };
    EachBlock.prototype.appendTo = function (parent, context, binding) {
        var items = this.expression.get(context);
        var start = document.createComment(this.expression.toString());
        var end = document.createComment(this.ending);
        parent.appendChild(start);
        if (items && items.length) {
            for (var i = 0, len = items.length; i < len; i++) {
                var itemContext = context.eachChild(this.expression, i);
                this.appendItemTo(parent, itemContext, start);
            }
        }
        else if (this.elseContent) {
            appendContent(parent, this.elseContent, context);
        }
        parent.appendChild(end);
        updateRange(context, binding, this, start, end);
    };
    EachBlock.prototype.appendItemTo = function (parent, context, itemFor, binding) {
        var before = parent.lastChild;
        var start, end;
        appendContent(parent, this.content, context);
        if (before === parent.lastChild) {
            start = end = document.createComment('empty');
            parent.appendChild(start);
        }
        else {
            start = (before && before.nextSibling) || parent.firstChild;
            end = parent.lastChild;
        }
        updateRange(context, binding, this, start, end, itemFor);
    };
    EachBlock.prototype.attachTo = function (parent, node, context) {
        var items = this.expression.get(context);
        var start = document.createComment(this.expression.toString());
        var end = document.createComment(this.ending);
        parent.insertBefore(start, node || null);
        if (items && items.length) {
            for (var i = 0, len = items.length; i < len; i++) {
                var itemContext = context.eachChild(this.expression, i);
                node = this.attachItemTo(parent, node, itemContext, start);
            }
        }
        else if (this.elseContent) {
            node = attachContent(parent, node, this.elseContent, context);
        }
        parent.insertBefore(end, node || null);
        updateRange(context, null, this, start, end);
        return node;
    };
    EachBlock.prototype.attachItemTo = function (parent, node, context, itemFor) {
        var start, end;
        var oldPrevious = node && node.previousSibling;
        var nextNode = attachContent(parent, node, this.content, context);
        if (nextNode === node) {
            start = end = document.createComment('empty');
            parent.insertBefore(start, node || null);
        }
        else {
            start = (oldPrevious && oldPrevious.nextSibling) || parent.firstChild;
            end = (nextNode && nextNode.previousSibling) || parent.lastChild;
        }
        updateRange(context, null, this, start, end, itemFor);
        return nextNode;
    };
    EachBlock.prototype.update = function (context, binding) {
        if (!binding.start.parentNode)
            return;
        var start = binding.start;
        var end = binding.end;
        var fragment;
        if (binding.itemFor) {
            fragment = document.createDocumentFragment();
            this.appendItemTo(fragment, context, binding.itemFor, binding);
        }
        else {
            fragment = this.getFragment(context, binding);
        }
        replaceRange(context, start, end, fragment, binding);
    };
    EachBlock.prototype.insert = function (context, binding, index, howMany) {
        var parent = binding.start.parentNode;
        if (!parent)
            return;
        // In case we are inserting all of the items, update instead. This is needed
        // when we were previously rendering elseContent so that it is replaced
        if (index === 0 && this.expression.get(context).length === howMany) {
            return this.update(context, binding);
        }
        var node = indexStartNode(binding, index);
        var fragment = document.createDocumentFragment();
        for (var i = index, len = index + howMany; i < len; i++) {
            var itemContext = context.eachChild(this.expression, i);
            this.appendItemTo(fragment, itemContext, binding.start);
        }
        parent.insertBefore(fragment, node || null);
    };
    EachBlock.prototype.remove = function (context, binding, index, howMany) {
        var parent = binding.start.parentNode;
        if (!parent)
            return;
        // In case we are removing all of the items, update instead. This is needed
        // when elseContent should be rendered
        if (index === 0 && this.expression.get(context).length === 0) {
            return this.update(context, binding);
        }
        var node = indexStartNode(binding, index);
        var i = 0;
        while (node) {
            if (node === binding.end)
                return;
            if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {
                if (howMany === i++)
                    return;
            }
            var nextNode = node.nextSibling;
            parent.removeChild(node);
            emitRemoved(context, node, binding);
            node = nextNode;
        }
    };
    EachBlock.prototype.move = function (context, binding, from, to, howMany) {
        var parent = binding.start.parentNode;
        if (!parent)
            return;
        var node = indexStartNode(binding, from);
        var fragment = document.createDocumentFragment();
        var i = 0;
        while (node) {
            if (node === binding.end)
                break;
            if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {
                if (howMany === i++)
                    break;
            }
            var nextNode = node.nextSibling;
            fragment.appendChild(node);
            node = nextNode;
        }
        node = indexStartNode(binding, to);
        parent.insertBefore(fragment, node || null);
    };
    EachBlock.prototype.serialize = function () {
        return serializeObject.instance(this, this.expression, this.content, this.elseContent);
    };
    EachBlock.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var dependencies = getDependencies(this.expression, context, options);
        var items = this.expression.get(context);
        if (items && items.length) {
            for (var i = 0; i < items.length; i++) {
                var itemContext = context.eachChild(this.expression, i);
                dependencies = concatArrayDependencies(dependencies, this.content, itemContext, options);
            }
        }
        else if (this.elseContent) {
            dependencies = concatArrayDependencies(dependencies, this.elseContent, context, options);
        }
        return dependencies;
    };
    return EachBlock;
}(Block));
exports.EachBlock = EachBlock;
//#region functions
function indexStartNode(binding, index) {
    var node = binding.start;
    var i = 0;
    while ((node = node.nextSibling)) {
        if (node === binding.end)
            return node;
        if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {
            if (index === i)
                return node;
            i++;
        }
    }
}
function updateRange(context, binding, template, start, end, itemFor, condition) {
    if (binding) {
        binding.start = start;
        binding.end = end;
        binding.condition = condition;
        setNodeBounds(binding, start, itemFor);
    }
    else {
        context.addBinding(new RangeBinding(template, context, start, end, itemFor, condition));
    }
}
function setNodeBounds(binding, start, itemFor) {
    if (itemFor) {
        setNodeProperty(start, '$bindItemStart', binding);
    }
    else {
        setNodeProperty(start, '$bindStart', binding);
    }
}
function appendContent(parent, content, context) {
    for (var i = 0, len = content.length; i < len; i++) {
        content[i].appendTo(parent, context);
    }
}
function attachContent(parent, node, content, context) {
    for (var i = 0, len = content.length; i < len; i++) {
        while (node && 'hasAttribute' in node && node.hasAttribute('data-no-attach')) {
            node = node.nextSibling;
        }
        node = content[i].attachTo(parent, node, context);
    }
    return node;
}
function contentHtml(content, context, unescaped) {
    var html = '';
    for (var i = 0, len = content.length; i < len; i++) {
        html += content[i].get(context, unescaped);
    }
    return html;
}
function replaceRange(context, start, end, fragment, binding, innerOnly) {
    // Note: the calling function must make sure to check that there is a parent
    var parent = start.parentNode;
    // Copy item binding from old start to fragment being inserted
    if (start.$bindItemStart && fragment.firstChild) {
        setNodeProperty(fragment.firstChild, '$bindItemStart', start.$bindItemStart);
        start.$bindItemStart.start = fragment.firstChild;
    }
    // Fast path for single node replacements
    if (start === end) {
        parent.replaceChild(fragment, start);
        emitRemoved(context, start, binding);
        return;
    }
    // Remove all nodes from start to end
    var node = (innerOnly) ? start.nextSibling : start;
    var nextNode;
    while (node) {
        nextNode = node.nextSibling;
        emitRemoved(context, node, binding);
        if (innerOnly && node === end) {
            nextNode = end;
            break;
        }
        parent.removeChild(node);
        if (node === end)
            break;
        node = nextNode;
    }
    // This also works if nextNode is null, by doing an append
    parent.insertBefore(fragment, nextNode || null);
}
function emitRemoved(context, node, ignore) {
    context.removeNode(node);
    emitRemovedBinding(context, ignore, node, '$bindNode');
    emitRemovedBinding(context, ignore, node, '$bindStart');
    emitRemovedBinding(context, ignore, node, '$bindItemStart');
    var attributes = node.$bindAttributes;
    if (attributes) {
        node.$bindAttributes = null;
        for (var key in attributes) {
            context.removeBinding(attributes[key]);
        }
    }
    for (node = node.firstChild; node; node = node.nextSibling) {
        emitRemoved(context, node, ignore);
    }
}
function emitRemovedBinding(context, ignore, node, property) {
    (0, util_1.checkKeyIsSafe)(property);
    var binding = node[property];
    if (binding) {
        node[property] = null;
        if (binding !== ignore) {
            context.removeBinding(binding);
        }
    }
}
function attachError(parent, node) {
    if (typeof console !== 'undefined') {
        console.error('Attach failed for', node, 'within', parent);
    }
    return new Error('Attaching bindings failed, because HTML structure ' +
        'does not match client rendering.');
}
//#endregion
var Binding = /** @class */ (function () {
    function Binding() {
        this.type = 'Binding';
        this.meta = null;
    }
    Binding.prototype.update = function (_previous, _pass) {
        this.context.pause();
        this.template.update(this.context, this);
        this.context.unpause();
    };
    Binding.prototype.insert = function (_index, _howMany) {
        this.update();
    };
    Binding.prototype.remove = function (_index, _howMany) {
        this.update();
    };
    Binding.prototype.move = function (_from, _to, _howMany) {
        this.update();
    };
    Binding.prototype.isUnbound = function () {
        return this.template.expression.isUnbound(this.context);
    };
    return Binding;
}());
exports.Binding = Binding;
var NodeBinding = /** @class */ (function (_super) {
    __extends(NodeBinding, _super);
    function NodeBinding(template, context, node) {
        var _this = _super.call(this) || this;
        _this.type = 'NodeBinding';
        _this.template = template;
        _this.context = context;
        _this.node = node;
        _this.meta = null;
        setNodeProperty(node, '$bindNode', _this);
        return _this;
    }
    return NodeBinding;
}(Binding));
exports.NodeBinding = NodeBinding;
var AttributeBindingsMap = /** @class */ (function () {
    function AttributeBindingsMap() {
    }
    return AttributeBindingsMap;
}());
exports.AttributeBindingsMap = AttributeBindingsMap;
var AttributeBinding = /** @class */ (function (_super) {
    __extends(AttributeBinding, _super);
    function AttributeBinding(template, context, element, name) {
        var _this = this;
        (0, util_1.checkKeyIsSafe)(name);
        _this = _super.call(this) || this;
        _this.type = 'AttributeBinding';
        _this.template = template;
        _this.context = context;
        _this.element = element;
        _this.name = name;
        _this.meta = null;
        var map = element.$bindAttributes ||
            (element.$bindAttributes = new AttributeBindingsMap());
        map[name] = _this;
        return _this;
    }
    return AttributeBinding;
}(Binding));
exports.AttributeBinding = AttributeBinding;
var RangeBinding = /** @class */ (function (_super) {
    __extends(RangeBinding, _super);
    function RangeBinding(template, context, start, end, itemFor, condition) {
        var _this = _super.call(this) || this;
        _this.type = 'RangeBinding';
        _this.template = template;
        _this.context = context;
        _this.start = start;
        _this.end = end;
        _this.itemFor = itemFor;
        _this.condition = condition;
        _this.meta = null;
        setNodeBounds(_this, start, itemFor);
        return _this;
    }
    RangeBinding.prototype.insert = function (index, howMany) {
        this.context.pause();
        if (this.template.insert) {
            this.template.insert(this.context, this, index, howMany);
        }
        else {
            this.template.update(this.context, this);
        }
        this.context.unpause();
    };
    RangeBinding.prototype.remove = function (index, howMany) {
        this.context.pause();
        if (this.template.remove) {
            this.template.remove(this.context, this, index, howMany);
        }
        else {
            this.template.update(this.context, this);
        }
        this.context.unpause();
    };
    RangeBinding.prototype.move = function (from, to, howMany) {
        this.context.pause();
        if (this.template.move) {
            this.template.move(this.context, this, from, to, howMany);
        }
        else {
            this.template.update(this.context, this);
        }
        this.context.unpause();
    };
    return RangeBinding;
}(Binding));
exports.RangeBinding = RangeBinding;
//#region
/// Utility functions ///
function escapeHtml(string) {
    string = string + '';
    return string.replace(/[&<]/g, function (match) {
        return (match === '&') ? '&amp;' : '&lt;';
    });
}
function escapeAttribute(string) {
    string = string + '';
    return string.replace(/[&"]/g, function (match) {
        return (match === '&') ? '&amp;' : '&quot;';
    });
}
function equalConditions(a, b) {
    // First, test for strict equality
    if (a === b)
        return true;
    // Failing that, allow for template objects used as a condition to define a
    // custom `equals()` method to indicate equivalence
    return (a instanceof Template) && a.equals(b);
}
function hasNodeType(node, nodeType) {
    return node && node.nodeType === nodeType;
}
//#endregion
exports.emptyTemplate = new Template([]);
//#region Shims & workarounds ////
// General notes:
//
// In all cases, Node.insertBefore should have `|| null` after its second
// argument. IE works correctly when the argument is ommitted or equal
// to null, but it throws and error if it is equal to undefined.
if (!Array.isArray) {
    // @ts-expect-error Shim defining Array.isArray
    Array.isArray = function (value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    };
}
// Equivalent to textNode.splitText, which is buggy in IE <=9
function splitData(node, index) {
    var newNode = node.cloneNode(false);
    newNode.deleteData(0, index);
    node.deleteData(index, node.length - index);
    node.parentNode.insertBefore(newNode, node.nextSibling || null);
    return newNode;
}
// Defined so that it can be overriden in IE <=8
var setNodeProperty = function (node, key, value) {
    return node[key] = value;
};
var normalizeLineBreaks = function (value) { return value; };
(function () {
    // Don't try to shim in Node.js environment
    if (typeof document === 'undefined')
        return;
    var div = document.createElement('div');
    div.innerHTML = '\r\n<br>\n';
    // @ts-expect-error Property `data` does not exist on ChildNode
    var windowsLength = div.firstChild.data.length;
    // @ts-expect-error Property `data` does not exist on ChildNode
    var unixLength = div.lastChild.data.length;
    if (windowsLength === 1 && unixLength === 1) {
        normalizeLineBreaks = function (value) {
            return value.replace(/\r\n/g, '\n');
        };
    }
    else if (windowsLength === 2 && unixLength === 2) {
        normalizeLineBreaks = function (value) {
            return value.replace(/(^|[^\r])(\n+)/g, function (match, value, newLines) {
                for (var i = newLines.length; i--;) {
                    value += '\r\n';
                }
                return value;
            });
        };
    }
    // TODO: Shim createHtmlFragment for old IE
    // TODO: Shim setAttribute('style'), which doesn't work in IE <=7
    // http://webbugtrack.blogspot.com/2007/10/bug-245-setattribute-style-does-not.html
    // TODO: Investigate whether input name attribute works in IE <=7. We could
    // override Element::appendTo to use IE's alternative createElement syntax:
    // document.createElement('<input name="xxx">')
    // http://webbugtrack.blogspot.com/2007/10/bug-235-createelement-is-broken-in-ie.html
    // In IE, input.defaultValue doesn't work correctly, so use input.value,
    // which mistakenly but conveniently sets both the value property and attribute.
    //
    // Surprisingly, in IE <=7, input.defaultChecked must be used instead of
    // input.checked before the input is in the document.
    // http://webbugtrack.blogspot.com/2007/11/bug-299-setattribute-checked-does-not.html
    var input = document.createElement('input');
    input.defaultValue = 'x';
    if (input.value !== 'x') {
        exports.CREATE_PROPERTIES.value = 'value';
    }
    try {
        // TextNodes are not expando in IE <=8
        // @ts-expect-error $try does not exist on Text
        document.createTextNode('').$try = 0;
    }
    catch (err) {
        setNodeProperty = function (node, key, value) {
            // If trying to set a property on a TextNode, create a proxy CommentNode
            // and set the property on that node instead. Put the proxy after the
            // TextNode if marking the end of a range, and before otherwise.
            if (node.nodeType === 3) {
                var proxyNode = node.previousSibling;
                if (!proxyNode || proxyNode.$bindProxy !== node) {
                    proxyNode = document.createComment('proxy');
                    proxyNode.$bindProxy = node;
                    node.parentNode.insertBefore(proxyNode, node || null);
                }
                return proxyNode[key] = value;
            }
            // Set the property directly on other node types
            return node[key] = value;
        };
    }
})();
function concatSubArrayDependencies(dependencies, expressions, context, options, end) {
    for (var i = 0; i <= end; i++) {
        dependencies = concatDependencies(dependencies, expressions[i], context, options);
    }
    return dependencies;
}
function concatArrayDependencies(dependencies, expressions, context, options) {
    for (var i = 0; i < expressions.length; i++) {
        dependencies = concatDependencies(dependencies, expressions[i], context, options);
    }
    return dependencies;
}
function concatMapDependencies(dependencies, expressions, context, options) {
    for (var key in expressions) {
        dependencies = concatDependencies(dependencies, expressions[key], context, options);
    }
    return dependencies;
}
function concatDependencies(dependencies, expression, context, options) {
    var expressionDependencies = getDependencies(expression, context, options);
    return (0, util_1.concat)(dependencies, expressionDependencies);
}
function getDependencies(expression, context, options) {
    return expression.dependencies(context, options);
}
var MarkupHook = /** @class */ (function () {
    function MarkupHook() {
        this.module = NAMESPACE;
    }
    return MarkupHook;
}());
exports.MarkupHook = MarkupHook;
var Hook = /** @class */ (function (_super) {
    __extends(Hook, _super);
    function Hook() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'hook';
        return _this;
    }
    Hook.prototype.emit = function (context, node) {
        node.$component = context.controller;
        context.controller.markerNode = node;
    };
    return Hook;
}(MarkupHook));
var markerHooks = [new Hook()];
var Marker = /** @class */ (function (_super) {
    __extends(Marker, _super);
    function Marker(data) {
        var _this = _super.call(this, data, markerHooks) || this;
        _this.type = 'Marker';
        return _this;
    }
    Marker.prototype.serialize = function () {
        return serializeObject.instance(this, this.data);
    };
    Marker.prototype.get = function () {
        return '';
    };
    return Marker;
}(Comment));
exports.Marker = Marker;
function ViewAttributesMap(source) {
    var items = source.split(/\s+/);
    for (var i = 0, len = items.length; i < len; i++) {
        (0, util_1.checkKeyIsSafe)(items[i]);
        this[items[i]] = true;
    }
}
function ViewArraysMap(source) {
    var items = source.split(/\s+/);
    for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i].split('/');
        (0, util_1.checkKeyIsSafe)(item[0]);
        this[item[0]] = item[1] || item[0];
    }
}
var View = /** @class */ (function (_super) {
    __extends(View, _super);
    function View(views, name, source, options) {
        var _this = _super.call(this) || this;
        _this.type = 'View';
        _this.views = views;
        _this.name = name;
        _this.source = source;
        _this.options = options;
        var nameSegments = (_this.name || '').split(':');
        var lastSegment = nameSegments.pop();
        _this.namespace = nameSegments.join(':');
        _this.registeredName = (lastSegment === 'index') ? _this.namespace : _this.name;
        _this.attributesMap = options && options.attributes &&
            new ViewAttributesMap(options.attributes);
        _this.arraysMap = options && options.arrays &&
            new ViewArraysMap(options.arrays);
        // The empty string is considered true for easier HTML attribute parsing
        _this.unminified = !!(options && (options.unminified || options.unminified === ''));
        _this.string = !!(options && (options.string || options.string === ''));
        _this.literal = !!(options && (options.literal || options.literal === ''));
        _this.template = null;
        _this.componentFactory = null;
        _this.fromSerialized = false;
        return _this;
    }
    View.prototype.serialize = function () {
        return null;
    };
    View.prototype._isComponent = function (context) {
        if (!this.componentFactory)
            return false;
        if (context.attributes && context.attributes.extend)
            return false;
        return true;
    };
    View.prototype._initComponent = function (context) {
        return (this._isComponent(context)) ?
            this.componentFactory.init(context) : context;
    };
    View.prototype._queueCreate = function (context, viewContext) {
        if (this._isComponent(context)) {
            var componentFactory_1 = this.componentFactory;
            context.queue(function queuedCreate() {
                componentFactory_1.create(viewContext);
            });
            if (!context.hooks)
                return;
            context.queue(function queuedComponentHooks() {
                // Kick off hooks if view instance specified `on` or `as` attributes
                for (var i = 0, len = context.hooks.length; i < len; i++) {
                    context.hooks[i].emit(context, viewContext.controller);
                }
            });
        }
    };
    View.prototype.get = function (context, unescaped) {
        var viewContext = this._initComponent(context);
        var template = this.template || this.parse();
        return template.get(viewContext, unescaped);
    };
    View.prototype.getFragment = function (context, binding) {
        var viewContext = this._initComponent(context);
        var template = this.template || this.parse();
        var fragment = template.getFragment(viewContext, binding);
        this._queueCreate(context, viewContext);
        return fragment;
    };
    View.prototype.appendTo = function (parent, context) {
        var viewContext = this._initComponent(context);
        var template = this.template || this.parse();
        template.appendTo(parent, viewContext);
        this._queueCreate(context, viewContext);
    };
    View.prototype.attachTo = function (parent, node, context) {
        var viewContext = this._initComponent(context);
        var template = this.template || this.parse();
        node = template.attachTo(parent, node, viewContext);
        this._queueCreate(context, viewContext);
        return node;
    };
    View.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var template = this.template || this.parse();
        // We can't figure out relative path dependencies within a component without
        // rendering it, because each component instance's scope is dynamically set
        // based on its unique `id` property. To represent this, set the context
        // controller to `null`.
        //
        // Under normal rendering conditions, contexts should always have reference
        // to a controller. Expression::get() methods use the reference to
        // `context.controller.model.data` to lookup values, and paths are resolved
        // based on `context.controller.model._scope`.
        //
        // To handle this, Expression methods guard against a null controller by not
        // returning any dependencies for model paths. In addition, they return
        // `undefined` from get, which affect dependencies computed for
        // ConditionalBlock and EachBlock, as their dependencies will differ based
        // on the value of model data.
        //
        // TODO: This likely under-estimates the true dependencies within a
        // template. However, to provide a more complete view of dependencies, we'd
        // need information we only have at render time, namely, the scope and data
        // within the component model. This may indicate that Derby should use a
        // more Functional Reactive Programming (FRP)-like approach of having
        // dependencies be returned from getFragment and attach methods along with
        // DOM nodes rather than computing dependencies separately from rendering.
        var viewContext = (this._isComponent(context)) ?
            context.componentChild(null) : context;
        return template.dependencies(viewContext, options);
    };
    View.prototype.parse = function () {
        this._parse();
        if (this.componentFactory && !this.componentFactory.constructorFn.prototype.singleton) {
            var marker = new Marker(this.name);
            this.template.content.unshift(marker);
        }
        return this.template;
    };
    // _parse is defined in parsing.js, so that it doesn't have to
    // be included in the client if templates are all parsed server-side
    View.prototype._parse = function () {
        throw new Error('View parsing not available');
    };
    return View;
}(Template));
exports.View = View;
var BaseViewInstance = /** @class */ (function (_super) {
    __extends(BaseViewInstance, _super);
    function BaseViewInstance() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseViewInstance.prototype.get = function (context, unescaped) {
        var view = this._find(context);
        var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);
        return view.get(viewContext, unescaped);
    };
    BaseViewInstance.prototype.getFragment = function (context, binding) {
        var view = this._find(context);
        var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);
        return view.getFragment(viewContext, binding);
    };
    BaseViewInstance.prototype.appendTo = function (parent, context) {
        var view = this._find(context);
        var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);
        view.appendTo(parent, viewContext);
    };
    BaseViewInstance.prototype.attachTo = function (parent, node, context) {
        var view = this._find(context);
        var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);
        return view.attachTo(parent, node, viewContext);
    };
    return BaseViewInstance;
}(Template));
var ViewInstance = /** @class */ (function (_super) {
    __extends(ViewInstance, _super);
    function ViewInstance(name, attributes, hooks, initHooks) {
        var _this = _super.call(this) || this;
        _this.type = 'ViewInstance';
        _this.name = name;
        _this.attributes = attributes;
        _this.hooks = hooks;
        _this.initHooks = initHooks;
        _this.view = null;
        return _this;
    }
    ViewInstance.prototype.serialize = function () {
        return serializeObject.instance(this, this.name, this.attributes, this.hooks, this.initHooks);
    };
    ViewInstance.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var view = this._find(context);
        var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);
        return view.dependencies(viewContext, options);
    };
    ViewInstance.prototype._find = function (context) {
        if (this.view)
            return this.view;
        var contextView = context.getView();
        var namespace = contextView && contextView.namespace;
        this.view = context.meta.views.find(this.name, namespace);
        if (!this.view) {
            var message = context.meta.views.findErrorMessage(this.name, contextView);
            throw new Error(message);
        }
        return this.view;
    };
    return ViewInstance;
}(BaseViewInstance));
exports.ViewInstance = ViewInstance;
var DynamicViewInstance = /** @class */ (function (_super) {
    __extends(DynamicViewInstance, _super);
    function DynamicViewInstance(nameExpression, attributes, hooks, initHooks) {
        var _this = _super.call(this) || this;
        _this.type = 'DynamicViewInstance';
        _this.attributes = attributes;
        _this.hooks = hooks;
        _this.initHooks = initHooks;
        _this.nameExpression = nameExpression;
        return _this;
    }
    DynamicViewInstance.prototype.serialize = function () {
        return serializeObject.instance(this, this.nameExpression, this.attributes, this.hooks, this.initHooks);
    };
    DynamicViewInstance.prototype._find = function (context) {
        var name = this.nameExpression.get(context);
        var contextView = context.getView();
        var namespace = contextView && contextView.namespace;
        var view = name && context.meta.views.find(name, namespace);
        return view || exports.emptyTemplate;
    };
    DynamicViewInstance.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var nameDependencies = this.nameExpression.dependencies(context);
        var viewDependencies = ViewInstance.prototype.dependencies.call(this, context, options);
        return (0, util_1.concat)(nameDependencies, viewDependencies);
    };
    return DynamicViewInstance;
}(BaseViewInstance));
exports.DynamicViewInstance = DynamicViewInstance;
// Without a ContextClosure, ViewParent will return the nearest context that
// is the parent of a view instance. When a context with a `closure` property
// is encountered first, ViewParent will find the specific referenced context,
// even if it is further up the context hierarchy.
var ViewParent = /** @class */ (function (_super) {
    __extends(ViewParent, _super);
    function ViewParent(template) {
        var _this = _super.call(this) || this;
        _this.type = 'ViewParent';
        _this.template = template;
        return _this;
    }
    ViewParent.prototype.serialize = function () {
        return serializeObject.instance(this, this.template);
    };
    ViewParent.prototype.get = function (context, unescaped) {
        var parentContext = context.forViewParent();
        return this.template.get(parentContext, unescaped);
    };
    ViewParent.prototype.getFragment = function (context, binding) {
        var parentContext = context.forViewParent();
        return this.template.getFragment(parentContext, binding);
    };
    ViewParent.prototype.appendTo = function (parent, context) {
        var parentContext = context.forViewParent();
        this.template.appendTo(parent, parentContext);
    };
    ViewParent.prototype.attachTo = function (parent, node, context) {
        var parentContext = context.forViewParent();
        return this.template.attachTo(parent, node, parentContext);
    };
    ViewParent.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this, options))
            return;
        var parentContext = context.forViewParent();
        return this.template.dependencies(parentContext, options);
    };
    return ViewParent;
}(Template));
exports.ViewParent = ViewParent;
// At render time, this template creates a context child and sets its
// `closure` property to a fixed reference. It is used in combination with
// ViewParent in order to control which context is returned.
//
// Instances of this template cannot be serialized. It is intended for use
// dynamically during rendering only.
var ContextClosure = /** @class */ (function (_super) {
    __extends(ContextClosure, _super);
    function ContextClosure(template, context) {
        var _this = _super.call(this) || this;
        _this.template = template;
        _this.context = context;
        return _this;
    }
    ContextClosure.prototype.serialize = function () {
        throw new Error('ContextClosure cannot be serialized');
    };
    ContextClosure.prototype.get = function (context, unescaped) {
        var closureContext = context.closureChild(this.context);
        return this.template.get(closureContext, unescaped);
    };
    ContextClosure.prototype.getFragment = function (context, binding) {
        var closureContext = context.closureChild(this.context);
        return this.template.getFragment(closureContext, binding);
    };
    ContextClosure.prototype.appendTo = function (parent, context) {
        var closureContext = context.closureChild(this.context);
        this.template.appendTo(parent, closureContext);
    };
    ContextClosure.prototype.attachTo = function (parent, node, context) {
        var closureContext = context.closureChild(this.context);
        return this.template.attachTo(parent, node, closureContext);
    };
    ContextClosure.prototype.dependencies = function (context, options) {
        if (dependencyOptions_1.DependencyOptions.shouldIgnoreTemplate(this.template, options))
            return;
        var closureContext = context.closureChild(this.context);
        return this.template.dependencies(closureContext, options);
    };
    ContextClosure.prototype.equals = function (other) {
        return (other instanceof ContextClosure) &&
            (this.context === other.context) &&
            (this.template.equals(other.template));
    };
    return ContextClosure;
}(Template));
exports.ContextClosure = ContextClosure;
var ViewsMap = /** @class */ (function () {
    function ViewsMap() {
    }
    return ViewsMap;
}());
var Views = /** @class */ (function () {
    function Views() {
        this.nameMap = new ViewsMap();
        this.tagMap = new ViewsMap();
        // TODO: elementMap is deprecated and should be removed with Derby 0.6.0
        this.elementMap = this.tagMap;
    }
    Views.prototype.find = function (name, namespace) {
        var map = this.nameMap;
        // Exact match lookup
        var exactName = (namespace) ? namespace + ':' + name : name;
        var match = map[exactName];
        if (match)
            return match;
        // Relative lookup
        var segments = name.split(':');
        var segmentsDepth = segments.length;
        if (namespace)
            segments = namespace.split(':').concat(segments);
        // Iterate through segments, leaving the `segmentsDepth` segments and
        // removing the second to `segmentsDepth` segment to traverse up the
        // namespaces. Decrease `segmentsDepth` if not found and repeat again.
        while (segmentsDepth > 0) {
            var testSegments = segments.slice();
            while (testSegments.length > segmentsDepth) {
                testSegments.splice(-1 - segmentsDepth, 1);
                var testName = testSegments.join(':');
                var match_1 = map[testName];
                if (match_1)
                    return match_1;
            }
            segmentsDepth--;
        }
    };
    Views.prototype.register = function (name, source, options) {
        var mapName = name.replace(/:index$/, '');
        (0, util_1.checkKeyIsSafe)(mapName);
        var view = this.nameMap[mapName];
        if (view) {
            // Recreate the view if it already exists. We re-apply the constructor
            // instead of creating a new view object so that references to object
            // can be cached after finding the first time
            var componentFactory = view.componentFactory;
            View.call(view, this, name, source, options);
            view.componentFactory = componentFactory;
        }
        else {
            view = new View(this, name, source, options);
        }
        this.nameMap[mapName] = view;
        // TODO: element is deprecated and should be removed with Derby 0.6.0
        var tagName = options && (options.tag || options.element);
        (0, util_1.checkKeyIsSafe)(tagName);
        if (tagName)
            this.tagMap[tagName] = view;
        return view;
    };
    Views.prototype.deserialize = function (items) {
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var setTemplate = item[0];
            var name_1 = item[1];
            var source = item[2];
            var options = item[3];
            var view = this.register(name_1, source, options);
            view.parse = setTemplate;
            view.fromSerialized = true;
        }
    };
    Views.prototype.serialize = function (options) {
        var forServer = options && options.server;
        var minify = options && options.minify;
        var items = [];
        for (var name_2 in this.nameMap) {
            var view = this.nameMap[name_2];
            var template = view.template || view.parse();
            if (!forServer && view.options) {
                // Do not serialize views with the `serverOnly` option, except when
                // serializing for a server script
                if (view.options.serverOnly)
                    continue;
                // For views with the `server` option, serialize them with a blank
                // template body. This allows them to be used from other views on the
                // browser, but they will output nothing on the browser
                if (view.options.server)
                    template = exports.emptyTemplate;
            }
            // Serializing views as a function allows them to be constructed lazily upon
            // first use. This can improve initial load times of the application when
            // there are many views
            items.push('[function(){return this.template=' +
                template.serialize() + '},' +
                serializeObject.args([
                    view.name,
                    (minify) ? null : view.source,
                    ((0, util_1.hasKeys)(view.options)) ? view.options : null
                ]) +
                ']');
        }
        return 'function(derbyTemplates, views){' +
            'var expressions = derbyTemplates.expressions,' +
            'templates = derbyTemplates.templates;' +
            'views.deserialize([' + items.join(',') + '])}';
    };
    Views.prototype.findErrorMessage = function (name, contextView) {
        var names = Object.keys(this.nameMap);
        var message = 'Cannot find view "' + name + '" in' +
            [''].concat(names).join('\n  ') + '\n';
        if (contextView) {
            message += '\nWithin template "' + contextView.name + '":\n' + contextView.source;
        }
        return message;
    };
    return Views;
}());
exports.Views = Views;
var ElementOn = /** @class */ (function (_super) {
    __extends(ElementOn, _super);
    function ElementOn(name, expression) {
        var _this = _super.call(this) || this;
        _this.type = 'ElementOn';
        _this.name = name;
        _this.expression = expression;
        return _this;
    }
    ElementOn.prototype.serialize = function () {
        return serializeObject.instance(this, this.name, this.expression);
    };
    ElementOn.prototype.emit = function (context, element) {
        if (this.name === 'create') {
            this.apply(context, element);
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var elementOn = this;
        var listener = function elementOnListener(event) {
            return elementOn.apply(context, element, event);
        };
        // Using `context.controller.dom.on` would be better for garbage collection,
        // but since it synchronously removes listeners on component destroy, it would
        // break existing code relying on `on-*` listeners firing as a component is
        // being destroyed. Even with `addEventListener`, browsers should still GC
        // the listeners once there are no references to the element.
        element.addEventListener(this.name, listener, false);
        // context.controller.dom.on(this.name, element, listener, false);
    };
    ElementOn.prototype.apply = function (context, element, event) {
        var modelData = context.controller.model.data;
        modelData.$event = event;
        modelData.$element = element;
        var out = this.expression.apply(context);
        delete modelData.$event;
        delete modelData.$element;
        return out;
    };
    return ElementOn;
}(MarkupHook));
exports.ElementOn = ElementOn;
var ComponentOn = /** @class */ (function (_super) {
    __extends(ComponentOn, _super);
    function ComponentOn(name, expression) {
        var _this = _super.call(this) || this;
        _this.type = 'ComponentOn';
        _this.name = name;
        _this.expression = expression;
        return _this;
    }
    ComponentOn.prototype.serialize = function () {
        return serializeObject.instance(this, this.name, this.expression);
    };
    ComponentOn.prototype.emit = function (context, component) {
        var expression = this.expression;
        component.on(this.name, function componentOnListener() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return expression.apply(context, args);
        });
    };
    return ComponentOn;
}(MarkupHook));
exports.ComponentOn = ComponentOn;
var AsPropertyBase = /** @class */ (function (_super) {
    __extends(AsPropertyBase, _super);
    function AsPropertyBase(segments) {
        var _this = _super.call(this) || this;
        _this.segments = segments;
        _this.lastSegment = segments.pop();
        return _this;
    }
    AsPropertyBase.prototype.serialize = function () {
        var segments = this.segments.concat(this.lastSegment);
        return serializeObject.instance(this, segments);
    };
    AsPropertyBase.prototype.emit = function (context, target) {
        var node = (0, util_1.traverseAndCreate)(context.controller, this.segments);
        (0, util_1.checkKeyIsSafe)(this.lastSegment);
        node[this.lastSegment] = target;
        this.addListeners(target, node, this.lastSegment);
    };
    AsPropertyBase.prototype.addListeners = function (target, object, key) {
        this.addDestroyListener(target, function asPropertyDestroy() {
            // memoize initial reference so we dont destroy
            // property that has been replaced with a different reference
            var intialRef = object[key];
            process.nextTick(function deleteProperty() {
                if (intialRef !== object[key]) {
                    return;
                }
                delete object[key];
            });
        });
    };
    return AsPropertyBase;
}(MarkupHook));
var AsProperty = /** @class */ (function (_super) {
    __extends(AsProperty, _super);
    function AsProperty() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'AsProperty';
        _this.addDestroyListener = elementAddDestroyListener;
        return _this;
    }
    return AsProperty;
}(AsPropertyBase));
exports.AsProperty = AsProperty;
var AsPropertyComponent = /** @class */ (function (_super) {
    __extends(AsPropertyComponent, _super);
    function AsPropertyComponent(segments) {
        var _this = _super.call(this, segments) || this;
        _this.type = 'AsPropertyComponent';
        _this.addDestroyListener = componentAddDestroyListener;
        return _this;
    }
    return AsPropertyComponent;
}(AsPropertyBase));
exports.AsPropertyComponent = AsPropertyComponent;
var AsObject = /** @class */ (function (_super) {
    __extends(AsObject, _super);
    function AsObject(segments, keyExpression) {
        var _this = _super.call(this, segments) || this;
        _this.type = 'AsObject';
        _this.keyExpression = keyExpression;
        return _this;
    }
    AsObject.prototype.serialize = function () {
        var segments = this.segments.concat(this.lastSegment);
        return serializeObject.instance(this, segments, this.keyExpression);
    };
    AsObject.prototype.emit = function (context, target) {
        var node = (0, util_1.traverseAndCreate)(context.controller, this.segments);
        (0, util_1.checkKeyIsSafe)(this.lastSegment);
        var object = node[this.lastSegment] || (node[this.lastSegment] = {});
        var key = this.keyExpression.get(context);
        (0, util_1.checkKeyIsSafe)(key);
        object[key] = target;
        this.addListeners(target, object, key);
    };
    return AsObject;
}(AsProperty));
exports.AsObject = AsObject;
var AsObjectComponent = /** @class */ (function (_super) {
    __extends(AsObjectComponent, _super);
    function AsObjectComponent(segments, keyExpression) {
        var _this = _super.call(this, segments, keyExpression) || this;
        _this.type = 'AsObjectComponent';
        _this.addDestroyListener = componentAddDestroyListener;
        return _this;
    }
    return AsObjectComponent;
}(AsObject));
exports.AsObjectComponent = AsObjectComponent;
var AsArrayBase = /** @class */ (function (_super) {
    __extends(AsArrayBase, _super);
    function AsArrayBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'AsArrayBase';
        return _this;
    }
    AsArrayBase.prototype.emit = function (context, target) {
        var node = (0, util_1.traverseAndCreate)(context.controller, this.segments);
        (0, util_1.checkKeyIsSafe)(this.lastSegment);
        var array = node[this.lastSegment] || (node[this.lastSegment] = []);
        // Iterate backwards, since rendering will usually append
        for (var i = array.length; i--;) {
            var item = array[i];
            // Don't add an item if already in the array
            if (item === target)
                return;
            var mask = this.comparePosition(target, item);
            // If the emitted target is after the current item in the document,
            // insert it next in the array
            // Node.DOCUMENT_POSITION_FOLLOWING = 4
            if (mask & 4) {
                array.splice(i + 1, 0, target);
                this.addListeners(target, array);
                return;
            }
        }
        // Add to the beginning if before all items
        array.unshift(target);
        this.addListeners(target, array);
    };
    AsArrayBase.prototype.addListeners = function (target, array) {
        this.addDestroyListener(target, function asArrayDestroy() {
            removeArrayItem(array, target);
        });
    };
    return AsArrayBase;
}(AsPropertyBase));
var AsArray = /** @class */ (function (_super) {
    __extends(AsArray, _super);
    function AsArray(segments) {
        var _this = _super.call(this, segments) || this;
        _this.type = 'AsArray';
        _this.addDestroyListener = elementAddDestroyListener;
        return _this;
    }
    AsArray.prototype.comparePosition = function (target, item) {
        return item.compareDocumentPosition(target);
    };
    return AsArray;
}(AsArrayBase));
exports.AsArray = AsArray;
var AsArrayComponent = /** @class */ (function (_super) {
    __extends(AsArrayComponent, _super);
    function AsArrayComponent(segments) {
        var _this = _super.call(this, segments) || this;
        _this.type = 'AsArrayComponent';
        _this.addDestroyListener = componentAddDestroyListener;
        return _this;
    }
    AsArrayComponent.prototype.comparePosition = function (target, item) {
        return item.markerNode.compareDocumentPosition(target.markerNode);
    };
    return AsArrayComponent;
}(AsArrayBase));
exports.AsArrayComponent = AsArrayComponent;
function elementAddDestroyListener(element, listener) {
    var destroyListeners = element.$destroyListeners;
    if (destroyListeners) {
        if (destroyListeners.indexOf(listener) === -1) {
            destroyListeners.push(listener);
        }
    }
    else {
        element.$destroyListeners = [listener];
    }
}
exports.elementAddDestroyListener = elementAddDestroyListener;
function elementRemoveDestroyListener(element, listener) {
    var destroyListeners = element.$destroyListeners;
    if (destroyListeners) {
        removeArrayItem(destroyListeners, listener);
    }
}
exports.elementRemoveDestroyListener = elementRemoveDestroyListener;
// TODO: Change target to Component once Component is in TS and has EventEmitter as ancestor
function componentAddDestroyListener(target, listener) {
    target.on('destroy', listener);
}
function removeArrayItem(array, item) {
    var index = array.indexOf(item);
    if (index > -1) {
        array.splice(index, 1);
    }
}
