import { type Expression } from './expressions';
import { type Attributes, type MarkupHook, type View } from './templates';
import { Controller } from '../Controller';
/**
 * Properties and methods which are globally inherited for the entire page
 */
export declare class ContextMeta {
    addBinding: (binding: any) => void;
    removeBinding: (binding: any) => void;
    removeNode: (node: Node) => void;
    addItemContext: (context: Context) => void;
    removeItemContext: (context: Context) => void;
    views: any;
    idNamespace: string;
    idCount: number;
    pending: any[];
    pauseCount: number;
}
export declare class Context {
    meta: ContextMeta;
    controller: Controller;
    parent?: Context;
    unbound?: boolean;
    expression?: Expression;
    alias?: string;
    keyAlias?: string;
    item?: number;
    view?: View;
    attributes?: Attributes;
    hooks?: MarkupHook<any>[];
    initHooks?: MarkupHook<any>[];
    closure?: Context;
    _id?: number;
    _eventModels?: any;
    constructor(meta: ContextMeta, controller: Controller, parent?: Context, unbound?: boolean, expression?: Expression);
    /**
     * Generate unique Id
     *
     * @returns namespaced Id
     */
    id(): string;
    addBinding(binding: any): void;
    removeBinding(binding: any): void;
    removeNode(node: any): void;
    child(expression: any): Context;
    componentChild(component: any): Context;
    /**
     * Make a context for an item in an each block
     *
     * @param expression
     * @param item
     * @returns new Context
     */
    eachChild(expression: any, item: any): Context;
    viewChild(view: any, attributes: any, hooks: any, initHooks: any): Context;
    closureChild(closure: any): Context;
    forRelative(expression: Expression): Context;
    forAlias(alias: string): Context;
    forAttribute(attribute: string): Context;
    forViewParent(): Context;
    /**
     * Gets the current `context` view or closest `context.parent` view
     *
     * @returns view
     */
    getView(): View;
    get(): any;
    pause(): void;
    unpause(): void;
    flush(): void;
    queue(cb: any): void;
}
