import { type Context } from './contexts';
import { type Expression } from './expressions';
import { Component } from '../components';
export type Attributes = Record<string, Attribute>;
type PathSegment = string | number;
export type Dependency = Array<PathSegment | Context>;
declare global {
    interface Node {
        $bindItemStart?: RangeBinding;
        $bindStart?: RangeBinding;
        $bindAttributes?: AttributeBindingsMap;
    }
    interface EventTarget {
        $destroyListeners?: any[];
    }
}
export declare const BOOLEAN_PROPERTIES: {
    checked: string;
    disabled: string;
    indeterminate: string;
    readonly: string;
    selected: string;
};
export declare const INTEGER_PROPERTIES: {
    colspan: string;
    maxlength: string;
    rowspan: string;
    tabindex: string;
};
export declare const STRING_PROPERTIES: {
    cellpadding: string;
    cellspacing: string;
    class: string;
    contenteditable: string;
    enctype: string;
    for: string;
    frameborder: string;
    id: string;
    title: string;
    type: string;
    usemap: string;
    value: string;
};
export declare const UPDATE_PROPERTIES: {
    cellpadding: string;
    cellspacing: string;
    class: string;
    contenteditable: string;
    enctype: string;
    for: string;
    frameborder: string;
    id: string;
    title: string;
    type: string;
    usemap: string;
    value: string;
    colspan: string;
    maxlength: string;
    rowspan: string;
    tabindex: string;
    checked: string;
    disabled: string;
    indeterminate: string;
    readonly: string;
    selected: string;
};
export declare const CREATE_PROPERTIES: {
    checked: string;
    value: string;
    cellpadding: string;
    cellspacing: string;
    class: string;
    contenteditable: string;
    enctype: string;
    for: string;
    frameborder: string;
    id: string;
    title: string;
    type: string;
    usemap: string;
    colspan: string;
    maxlength: string;
    rowspan: string;
    tabindex: string;
    disabled: string;
    indeterminate: string;
    readonly: string;
    selected: string;
};
export declare const VOID_ELEMENTS: {
    area: boolean;
    base: boolean;
    br: boolean;
    col: boolean;
    embed: boolean;
    hr: boolean;
    img: boolean;
    input: boolean;
    keygen: boolean;
    link: boolean;
    menuitem: boolean;
    meta: boolean;
    param: boolean;
    source: boolean;
    track: boolean;
    wbr: boolean;
};
export declare const NAMESPACE_URIS: {
    svg: string;
    xlink: string;
    xmlns: string;
};
export declare class Template {
    module: string;
    type: string;
    content: Template[];
    source: string;
    expression?: Expression;
    unbound?: boolean;
    hooks: MarkupHook<any>[];
    constructor(content?: Template[], source?: string);
    toString(): string;
    get(context: Context, unescaped: boolean): string | boolean;
    getFragment(context: Context, binding?: Binding): DocumentFragment;
    appendTo(parent: Node, context: Context, _binding?: Binding): void;
    attachTo(parent: Node, node: Node, context: Context): Node;
    update(_context: Context, _binding: Binding): void;
    stringify(value: string): string;
    equals(other: unknown): boolean;
    serialize(): string;
    isUnbound(context: Context): boolean;
    resolve(_context: Context): any;
    dependencies(context: Context, options?: {
        ignoreTemplate?: Template;
    }): Dependency[] | undefined;
}
export declare class Doctype extends Template {
    type: string;
    name: string;
    publicId: string;
    systemId: string;
    constructor(name: string, publicId: string, systemId: string);
    get(): string;
    appendTo(): void;
    attachTo(parent: Node, node: Node): ChildNode;
    serialize(): string;
    dependencies(): any;
}
export declare class Text extends Template {
    type: string;
    data: string;
    escaped: string;
    constructor(data: string);
    get(context: Context, unescaped: boolean): string;
    appendTo(parent: Node): void;
    attachTo(parent: Node, node: Node): any;
    serialize(): string;
    dependencies(): any;
}
export declare class DynamicText extends Template {
    expression: Expression;
    unbound: boolean;
    constructor(expression: Expression);
    get(context: Context, unescaped: boolean): any;
    appendTo(parent: Node, context: Context, binding: RangeBinding): void;
    attachTo(parent: Node, node: Node, context: Context): any;
    type: string;
    update(context: Context, binding: Binding): void;
    getCondition(context: Context): any;
    serialize(): string;
    _blockUpdate: (context: Context, binding: RangeBinding) => void;
    dependencies(context: Context, options?: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
export declare class Comment extends Template {
    data: string;
    hooks: MarkupHook<any>[];
    type: string;
    constructor(data: string, hooks?: MarkupHook<any>[]);
    get(): string;
    appendTo(parent: Node, context: Context): void;
    attachTo(parent: Node, node: Node, context: Context): any;
    serialize(): string;
    dependencies(): any;
}
export declare class DynamicComment extends Template {
    expression: Expression;
    hooks: MarkupHook<any>[];
    type: string;
    constructor(expression: Expression, hooks: MarkupHook<any>[]);
    get(context: Context): string;
    appendTo(parent: Node, context: Context): void;
    attachTo(parent: Node, node: Node, context: Context): any;
    update(context: Context, binding: NodeBinding): void;
    serialize(): string;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
export declare class Html extends Template {
    data: string;
    type: string;
    constructor(data: string);
    get(): string;
    appendTo(parent: Node): void;
    attachTo(parent: Node, node: Node): Node;
    serialize(): string;
    dependencies(): any;
}
export declare class DynamicHtml extends Template {
    ending: string;
    type: string;
    constructor(expression: Expression);
    get(context: Context): string;
    appendTo(parent: Node, context: Context, binding: RangeBinding): void;
    attachTo(parent: Node, node: Node, context: Context): Node;
    update(context: Context, binding: RangeBinding): void;
    serialize(): string;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
export declare class Attribute extends Template {
    data?: string | boolean;
    ns?: string;
    type: string;
    constructor(data?: string | boolean, ns?: string);
    get(_context?: Context): any;
    getBound(_context: Context, _element: globalThis.Element, _name: string, _elementNs: string): any;
    serialize(): string;
    dependencies(_context: Context, _options: any): any;
}
export declare class DynamicAttribute extends Attribute {
    expression: Expression;
    elementNs: string;
    type: string;
    constructor(expression: Expression, ns?: string);
    get(context: Context): any;
    getBound(context: Context, element: globalThis.Element, name: string, elementNs: string): any;
    update(context: Context, binding: AttributeBinding): void;
    serialize(): string;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
declare abstract class BaseElement<T> extends Template {
    attributes: Attributes;
    bindContentToValue: boolean;
    hooks: MarkupHook<any>[];
    notClosed: boolean;
    ns: string;
    selfClosing: boolean;
    startClose: string;
    tagName: T;
    unescapedContent: boolean;
    constructor(attributes: Attributes, content: Template[], hooks: MarkupHook<any>[], selfClosing: boolean, notClosed: boolean, ns: string);
    abstract getTagName(context: Context): string;
    abstract getEndTag(tagName: string): string;
    get(context: Context): string;
    appendTo(parent: Node, context: Context): void;
    attachTo(parent: Node, node: Node, context: Context): ChildNode;
    _bindContent(context: Context, element: globalThis.Element): void;
    serialize(): string;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
export declare class Element extends BaseElement<string> {
    type: string;
    endTag: string;
    constructor(tagName: string, attributes: Record<string, Attribute>, content: Template[], hooks: MarkupHook<any>[], selfClosing: boolean, notClosed: boolean, ns: string);
    getTagName(_context: Context): string;
    getEndTag(_tagName: string): string;
}
export declare class DynamicElement extends BaseElement<Expression> {
    type: string;
    content: Template[];
    attributes: Attributes;
    constructor(tagName: Expression, attributes: Attributes, content: Template[], hooks: any, selfClosing: boolean, notClosed: any, ns: any);
    getTagName(context: Context): any;
    getEndTag(tagName: string): string;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): any;
}
declare abstract class BaseBlock extends Template {
    ending: string;
}
export declare class Block extends BaseBlock {
    type: string;
    expression: Expression;
    constructor(expression: Expression, content: Template[]);
    get(context: Context, unescaped: boolean): string;
    appendTo(parent: Node, context: Context, binding: RangeBinding): void;
    attachTo(parent: Node, node: Node, context: Context): Node;
    serialize(): string;
    update(context: Context, binding: RangeBinding): void;
    getCondition(context: Context): any;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
export declare class ConditionalBlock extends BaseBlock {
    beginning: string;
    contents: Template[][];
    expressions: Expression[];
    type: string;
    constructor(expressions: Expression[], contents: Template[][]);
    get(context: Context, unescaped: boolean): string;
    appendTo(parent: Node, context: Context, binding: RangeBinding): void;
    attachTo(parent: Node, node: Node, context: Context): Node;
    serialize(): string;
    update(context: Context, binding: RangeBinding): void;
    getCondition(context: Context): number;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
export declare class EachBlock extends Block {
    type: string;
    elseContent: Template[];
    constructor(expression: Expression, content: Template[], elseContent?: Template[]);
    get(context: Context, unescaped: boolean): string;
    appendTo(parent: Node, context: Context, binding: RangeBinding): void;
    appendItemTo(parent: Node, context: Context, itemFor: globalThis.Comment, binding?: RangeBinding): void;
    attachTo(parent: Node, node: Node, context: Context): Node;
    attachItemTo(parent: Node, node: Node, context: Context, itemFor: globalThis.Comment): Node;
    update(context: Context, binding: RangeBinding): void;
    insert(context: Context, binding: RangeBinding, index: number, howMany: number): void;
    remove(context: Context, binding: RangeBinding, index: number, howMany: number): void;
    move(context: Context, binding: RangeBinding, from: number, to: number, howMany: number): void;
    serialize(): string;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
export declare class Binding {
    type: string;
    meta: any;
    context: Context;
    template: any;
    constructor();
    update(_previous?: any, _pass?: any): void;
    insert(_index: number, _howMany: number): void;
    remove(_index: number, _howMany: number): void;
    move(_from: number, _to: number, _howMany: number): void;
    isUnbound(): any;
}
export declare class NodeBinding extends Binding {
    type: string;
    node: Node;
    constructor(template: Template, context: Context, node: Node);
}
export declare class AttributeBindingsMap {
}
export declare class AttributeBinding extends Binding {
    type: string;
    element: globalThis.Element;
    name: string;
    constructor(template: DynamicAttribute, context: Context, element: globalThis.Element, name: string);
}
export declare class RangeBinding extends Binding {
    type: string;
    start: Node;
    end: Node;
    itemFor?: globalThis.Comment | null;
    condition: any;
    constructor(template: Template, context: Context, start: Node, end: Node, itemFor: globalThis.Comment | null | undefined, condition: any);
    insert(index: number, howMany: number): void;
    remove(index: number, howMany: number): void;
    move(from: number, to: number, howMany: number): void;
}
export declare const emptyTemplate: Template;
export declare abstract class MarkupHook<T> {
    module: string;
    name: string;
    abstract emit(context: Context, target: T): void;
}
export declare class Marker extends Comment {
    type: string;
    constructor(data: string);
    serialize(): string;
    get(): string;
}
interface ViewOptions {
    attributes?: any;
    arrays?: any;
    unminified?: string;
    string?: string;
    literal?: string;
    /**
     * Custom HTML tag name for the view, so it can be used like `<my-box/>`
     * in addition to the standard `<view is="my-box"/>`.
     */
    tag?: string;
    /** @deprecated - Use `tag` instead */
    element?: string;
    server?: boolean;
    /**
     * If true, the view is only for use in server code, and
     * Derby won't serialize the view for client code.
     */
    serverOnly?: boolean;
}
export declare class View extends Template {
    arraysMap: any;
    attributesMap: any;
    componentFactory: {
        constructorFn: any;
        init: any;
        create: any;
    };
    fromSerialized: boolean;
    literal: boolean;
    name: string;
    namespace: string;
    options: ViewOptions;
    registeredName: string;
    string: boolean;
    template: any;
    type: string;
    unminified: boolean;
    views: any;
    constructor(views: any, name: string, source: string, options: ViewOptions);
    serialize(): string;
    _isComponent(context: Context): boolean;
    _initComponent(context: Context): any;
    _queueCreate(context: Context, viewContext: {
        controller: any;
    }): void;
    get(context: Context, unescaped: boolean): any;
    getFragment(context: Context, binding: Binding): any;
    appendTo(parent: Node, context: Context): void;
    attachTo(parent: Node, node: Node, context: Context): Node;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): any;
    parse(): any;
    _parse(): void;
}
declare abstract class BaseViewInstance extends Template {
    attributes: any;
    hooks: any;
    initHooks: any;
    get(context: Context, unescaped: boolean): any;
    getFragment(context: Context, binding: Binding): any;
    appendTo(parent: Node, context: Context): void;
    attachTo(parent: Node, node: Node, context: Context): any;
    abstract _find(_context: Context): any;
}
export declare class ViewInstance extends BaseViewInstance {
    type: string;
    name: string;
    view: any;
    constructor(name: string, attributes: any, hooks: any, initHooks: any);
    serialize(): string;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): any;
    _find(context: Context): any;
}
export declare class DynamicViewInstance extends BaseViewInstance {
    type: string;
    nameExpression: any;
    constructor(nameExpression: any, attributes: any, hooks: any, initHooks: any);
    serialize(): string;
    _find(context: Context): any;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): any;
}
export declare class ViewParent extends Template {
    type: string;
    template: Template;
    constructor(template: Template);
    serialize(): string;
    get(context: Context, unescaped: boolean): string | boolean;
    getFragment(context: Context, binding: Binding): DocumentFragment;
    appendTo(parent: Node, context: Context): void;
    attachTo(parent: Node, node: Node, context: Context): Node;
    dependencies(context: Context, options: {
        ignoreTemplate?: Template;
    }): Dependency[];
}
export declare class ContextClosure extends Template {
    template: Template;
    context: Context;
    constructor(template: Template, context: Context);
    serialize(): string;
    get(context: Context, unescaped: boolean): string | boolean;
    getFragment(context: Context, binding: Binding): DocumentFragment;
    appendTo(parent: Node, context: Context): void;
    attachTo(parent: Node, node: Node, context: Context): Node;
    dependencies(context: Context, options: {
        ignoreTemplate: Template;
    }): Dependency[];
    equals(other: Template): boolean;
}
declare class ViewsMap {
}
export declare class Views {
    nameMap: ViewsMap;
    tagMap: ViewsMap;
    elementMap: ViewsMap;
    constructor();
    find(name: string, namespace?: string): any;
    register(name: string, source: string, options?: ViewOptions): any;
    deserialize(items: string | any[]): void;
    serialize(options?: {
        server?: boolean;
        minify?: boolean;
    }): string;
    findErrorMessage(name: string, contextView?: {
        name: string;
        source: string;
    }): string;
}
export declare class ElementOn extends MarkupHook<globalThis.Element> {
    type: string;
    name: string;
    expression: any;
    constructor(name: string, expression: any);
    serialize(): string;
    emit(context: Context, element: globalThis.Element): void;
    apply(context: Context, element: any, event?: any): any;
}
export declare class ComponentOn extends MarkupHook<any> {
    type: string;
    name: string;
    expression: any;
    constructor(name: string, expression: any);
    serialize(): string;
    emit(context: Context, component: {
        on: (arg0: string, arg1: (...args: any[]) => any) => void;
    }): void;
}
declare abstract class AsPropertyBase<T> extends MarkupHook<T> {
    type: string;
    segments: PathSegment[];
    lastSegment: PathSegment;
    constructor(segments: PathSegment[]);
    serialize(): string;
    emit(context: Context, target: T): void;
    addListeners(target: T, object: {
        [x: string]: any;
    }, key: string | number): void;
    abstract addDestroyListener(target: T, onDestroy: () => void): void;
}
export declare class AsProperty extends AsPropertyBase<globalThis.Element> {
    type: string;
    addDestroyListener: typeof elementAddDestroyListener;
}
export declare class AsPropertyComponent extends AsPropertyBase<Component> {
    type: string;
    constructor(segments: PathSegment[]);
    addDestroyListener: typeof componentAddDestroyListener;
}
export declare class AsObject extends AsProperty {
    type: string;
    keyExpression: any;
    constructor(segments: PathSegment[], keyExpression: any);
    serialize(): string;
    emit(context: Context, target: any): void;
}
export declare class AsObjectComponent extends AsObject {
    type: string;
    constructor(segments: PathSegment[], keyExpression: any);
    addDestroyListener: typeof componentAddDestroyListener;
}
declare abstract class AsArrayBase<T> extends AsPropertyBase<T> {
    type: string;
    emit(context: Context, target: any): void;
    addListeners(target: any, array: any): void;
    abstract comparePosition(target: T, item: T): number;
}
export declare class AsArray extends AsArrayBase<Node> {
    type: string;
    constructor(segments: PathSegment[]);
    comparePosition(target: Node, item: Node): number;
    addDestroyListener: typeof elementAddDestroyListener;
}
export declare class AsArrayComponent extends AsArrayBase<{
    markerNode: Node;
}> {
    type: string;
    constructor(segments: PathSegment[]);
    comparePosition(target: {
        markerNode: Node;
    }, item: {
        markerNode: Node;
    }): number;
    addDestroyListener: typeof componentAddDestroyListener;
}
export declare function elementAddDestroyListener(element: globalThis.Element, listener: any): void;
export declare function elementRemoveDestroyListener(element: {
    $destroyListeners: any;
}, listener: any): void;
declare function componentAddDestroyListener(target: any, listener: () => void): void;
export {};
