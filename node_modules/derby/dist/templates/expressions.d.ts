import { type Context } from './contexts';
import { DependencyOptions } from './dependencyOptions';
import { ContextClosure, Dependency, Template } from './templates';
type SegmentOrContext = string | number | {
    item: number;
} | Context;
type Segment = string;
type Value = any;
export declare function lookup(segments: Segment[] | undefined, value: Value): any;
export declare function templateTruthy(value: Value[] | PrimitiveValue): boolean;
export declare function pathSegments(segments: SegmentOrContext[]): Segment[];
type PrimitiveValue = string | number | boolean;
type Renderable = PrimitiveValue | Template | Record<string, Template>;
export declare function renderValue(value: Renderable, context: Context): Record<string, any> | PrimitiveValue | Renderable[];
export declare function renderTemplate(template: Renderable, context: Context): PrimitiveValue | Record<string, Template>;
export declare function renderArray(array: Renderable[], context: Context): Renderable[];
export declare function renderObject(object: Record<string, Template>, context: Context): Record<string, any>;
type BindType = 'bound' | 'unbound';
type ValueType = 'view' | undefined;
type BlockType = string;
export declare class ExpressionMeta {
    as: string;
    bindType: BindType;
    blockType: BlockType;
    isEnd: boolean;
    keyAs: string;
    module: string;
    source: string;
    type: string;
    unescaped: boolean;
    valueType: ValueType;
    constructor(source: string, blockType?: string, isEnd?: boolean, as?: string, keyAs?: string, unescaped?: boolean, bindType?: BindType, valueType?: ValueType);
    serialize(): string;
}
export declare class Expression {
    module: string;
    type: string;
    meta?: ExpressionMeta;
    segments: string[];
    constructor(meta?: ExpressionMeta);
    serialize(): string;
    toString(): string;
    truthy(context: Context): boolean;
    get(_context: Context, _flag?: boolean): any;
    resolve(_context: Context): SegmentOrContext[] | undefined;
    dependencies(_context: Context, _options: DependencyOptions): Dependency[] | undefined;
    pathSegments(context: Context): Segment[] | undefined;
    set(context: Context, value: Value): void;
    _resolvePatch(context: Context, segments: any): any;
    isUnbound(context: Pick<Context, 'unbound'>): boolean;
    _lookupAndContextifyValue(value: Renderable, context: Context): any;
}
export declare class LiteralExpression extends Expression {
    type: string;
    value: Value;
    constructor(value: Value, meta?: ExpressionMeta);
    serialize(): string;
    get(): any;
}
export declare class PathExpression extends Expression {
    type: string;
    segments: Segment[];
    constructor(segments: Segment[], meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): Record<string, any>;
    resolve(context: Context): any;
    dependencies(context: Context, options: DependencyOptions): any;
}
export declare class RelativePathExpression extends Expression {
    type: string;
    constructor(segments: Segment[], meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): any;
    resolve(context: Context): any;
    dependencies(context: Context, options: DependencyOptions): any[];
}
export declare class AliasPathExpression extends Expression {
    type: string;
    alias: string;
    constructor(alias: string, segments: Segment[], meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): any;
    resolve(context: Context): any;
    dependencies(context: Context, options: DependencyOptions): any;
}
export declare class AttributePathExpression extends Expression {
    type: string;
    attribute: any;
    constructor(attribute: any, segments: Segment[], meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): any;
    resolve(context: Context): any;
    dependencies(context: Context, options: DependencyOptions): any;
}
export declare class BracketsExpression extends Expression {
    type: string;
    before: any;
    inside: any;
    afterSegments: any;
    constructor(before: any, inside: any, afterSegments?: any, meta?: ExpressionMeta);
    serialize: () => any;
    get(context: Context): any;
    resolve(context: Context): any;
    dependencies(context: Context, options: any): any;
}
export declare class DeferRenderExpression extends Expression {
    template: Template;
    type: string;
    constructor(template: Template, meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): ContextClosure;
}
export declare class ArrayExpression extends Expression {
    items: any;
    afterSegments: any;
    type: string;
    constructor(items: any, afterSegments?: any, meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): any;
    dependencies(context: Context, options: DependencyOptions): any;
}
export declare class ObjectExpression extends Expression {
    properties: any;
    afterSegments: any;
    type: string;
    constructor(properties: any, afterSegments?: any, meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): any;
    dependencies(context: Context, options: DependencyOptions): any;
}
export declare class FnExpression extends Expression {
    args: any;
    afterSegments: any;
    lastSegment: Segment;
    parentSegments: Segment[] | null;
    type: string;
    constructor(segments: Segment[], args: any, afterSegments?: any, meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): any;
    apply(context: Context, extraInputs?: any[]): any;
    _lookupParent(context: Context): any;
    _getInputs(context: Context): any[];
    _applyFn(fn: {
        apply: (arg0: any, arg1: any[]) => any;
        call: (arg0: any) => any;
    }, context: Context, extraInputs: any[], thisArg: any): any;
    dependencies(context: Context, options: DependencyOptions): any[];
    set(context: Context, value: Value): void;
}
export declare class NewExpression extends FnExpression {
    type: string;
    constructor(segments: any, args: any, afterSegments?: any, meta?: ExpressionMeta);
    _applyFn(Fn: {
        new (): any;
        bind: {
            apply: (arg0: any, arg1: any[]) => any;
        };
    }, context: Context): any;
}
export declare class OperatorExpression extends FnExpression {
    type: string;
    name: string;
    getFn: any;
    setFn: any;
    constructor(name: string, args: any, afterSegments?: any, meta?: ExpressionMeta);
    serialize(): string;
    apply(context: Context): any;
    set(context: Context, value: Value): void;
}
export declare class SequenceExpression extends OperatorExpression {
    type: string;
    constructor(args: any, afterSegments?: any, meta?: ExpressionMeta);
    serialize(): string;
    getFn: (...args: any[]) => any;
    resolve(context: Context): any;
    dependencies(context: Context, options: DependencyOptions): any[];
}
export declare class ViewParentExpression extends Expression {
    type: string;
    expression: Expression;
    constructor(expression: Expression, meta?: ExpressionMeta);
    serialize(): string;
    get(context: Context): any;
    resolve(context: Context): SegmentOrContext[];
    dependencies(context: Context, options: any): Dependency[];
    pathSegments(context: Context): string[];
    set(context: Context, value: Value): void;
}
export declare class ScopedModelExpression extends Expression {
    expression: Expression;
    type: string;
    constructor(expression: Expression, meta?: ExpressionMeta);
    serialize(): any;
    get(context: Context): import("racer").ChildModel<unknown>;
    resolve(context: Context): SegmentOrContext[];
    dependencies(context: Context, options: any): Dependency[];
    pathSegments(context: Context): string[];
    set(context: Context, value: Value): void;
}
export {};
